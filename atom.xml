<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moong2&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leekeunhwan.github.io/"/>
  <updated>2018-08-05T06:56:47.131Z</updated>
  <id>https://leekeunhwan.github.io/</id>
  
  <author>
    <name>Moong2</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>programmers-2016-Day</title>
    <link href="https://leekeunhwan.github.io/2018/08/05/programmers-2016-Day/"/>
    <id>https://leekeunhwan.github.io/2018/08/05/programmers-2016-Day/</id>
    <published>2018-08-05T06:55:18.000Z</published>
    <updated>2018-08-05T06:56:47.131Z</updated>
    
    <content type="html"><![CDATA[<h2>문제 설명</h2><p>2016 년 1 월 1 일은 금요일입니다.<br>2016 년 a 월 b 일은 무슨 요일일까요?<br>두 수 a ,b 를 입력받아 2016 년 a 월 b 일이 무슨 요일인지<br>리턴하는 함수, solution 을 완성하세요.</p><p>요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다.<br>예를 들어 a=5, b=24 라면 5 월 24 일은 화요일이므로 문자열 TUE 를 반환하세요.</p><h2>제한 조건</h2><p>2016 년은 윤년입니다.<br>2016 년 a 월 b 일은 실제로 있는 날입니다.<br>(13 월 26 일이나 2 월 45 일같은 날짜는 주어지지 않습니다)</p><h2>입출력 예</h2><p>a b result<br>5 24 TUE</p><h2>문제 풀이</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> day = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, a - <span class="number">1</span>, b).toString();</span><br><span class="line">  <span class="comment">// 2016년의 입력된 a월 b일의 요일을 찾아야하므로 new Date함수에 인자로 2016, a-1(0이 1월이기 때문), b를 넣어준 뒤</span></span><br><span class="line">  <span class="comment">// 해당 값은 객체이므로 요일을 자르기 위해 문자열로 만들어준다.</span></span><br><span class="line">  <span class="keyword">let</span> answer = day.slice(<span class="number">0</span>, <span class="number">3</span>).toUpperCase();</span><br><span class="line">  <span class="comment">// 요일 부분을 잘라 대문자로 만들어 준다. (출력되는 답이 대문자이기 때문)</span></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">  <span class="comment">// 정답 출력</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">solution(<span class="number">6</span>, <span class="number">19</span>); <span class="comment">// SUN</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;문제 설명&lt;/h2&gt;
&lt;p&gt;2016 년 1 월 1 일은 금요일입니다.&lt;br&gt;
2016 년 a 월 b 일은 무슨 요일일까요?&lt;br&gt;
두 수 a ,b 를 입력받아 2016 년 a 월 b 일이 무슨 요일인지&lt;br&gt;
리턴하는 함수, solution 을 
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://leekeunhwan.github.io/categories/Algorithm/"/>
    
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Algorithm" scheme="https://leekeunhwan.github.io/tags/Algorithm/"/>
    
      <category term="Programmers" scheme="https://leekeunhwan.github.io/tags/Programmers/"/>
    
      <category term="JavaScript" scheme="https://leekeunhwan.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>programmers-Str-To-Int</title>
    <link href="https://leekeunhwan.github.io/2018/08/04/programmers-Str-To-Int/"/>
    <id>https://leekeunhwan.github.io/2018/08/04/programmers-Str-To-Int/</id>
    <published>2018-08-03T15:20:34.000Z</published>
    <updated>2018-08-03T15:21:44.758Z</updated>
    
    <content type="html"><![CDATA[<h2>문제 설명</h2><p>strToInt 메소드는 String 형 str 을 매개변수로 받습니다.<br>str 을 숫자로 변환한 결과를 반환하도록 strToInt 를 완성하세요.<br>예를들어 str 이 1234 이면 1234 를 반환하고, -1234 이면 -1234 를 반환하면 됩니다.<br>str 은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다.</p><br><br><h2>문제 풀이</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strToInt</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>; <span class="comment">// 결과를 담을 변수 선언</span></span><br><span class="line">  result = <span class="built_in">parseInt</span>(str); <span class="comment">// 문자열인 매개변수를 숫자로 형변환하여 값으로 할당</span></span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 결과 출력</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 아래는 테스트로 출력해 보기 위한 코드입니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(strToInt(<span class="string">"-1234"</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;문제 설명&lt;/h2&gt;
&lt;p&gt;strToInt 메소드는 String 형 str 을 매개변수로 받습니다.&lt;br&gt;
str 을 숫자로 변환한 결과를 반환하도록 strToInt 를 완성하세요.&lt;br&gt;
예를들어 str 이 1234 이면 1234 를 반환하고,
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://leekeunhwan.github.io/categories/Algorithm/"/>
    
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Algorithm" scheme="https://leekeunhwan.github.io/tags/Algorithm/"/>
    
      <category term="Programmers" scheme="https://leekeunhwan.github.io/tags/Programmers/"/>
    
      <category term="JavaScript" scheme="https://leekeunhwan.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>programmers-Digit-Sums</title>
    <link href="https://leekeunhwan.github.io/2018/08/03/programmers-Digit-Sums/"/>
    <id>https://leekeunhwan.github.io/2018/08/03/programmers-Digit-Sums/</id>
    <published>2018-08-03T12:07:40.000Z</published>
    <updated>2018-08-03T12:10:04.405Z</updated>
    
    <content type="html"><![CDATA[<h2>문제 설명</h2><p>자연수 N 이 주어지면, N 의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요.<br>예를들어 N = 123 이면 1 + 2 + 3 = 6 을 return 하면 됩니다.</p><h2>제한사항</h2><p>N 의 범위 : 100,000,000 이하의 자연수</p><h2>입출력 예</h2><p>N answer<br>123 6<br>987 24</p><h3>입출력 예 설명</h3><p>입출력 예 #1<br>문제의 예시와 같습니다.</p><p>입출력 예 #2<br>9 + 8 + 7 = 24 이므로 24 를 return 하면 됩니다.</p><h2>문제 풀이</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> numStr = n.toString(); <span class="comment">// 자연수인데 length를 쓰기 위해 문자열로 형변환</span></span><br><span class="line">  <span class="keyword">let</span> answer = <span class="number">0</span>; <span class="comment">// 정답을 담을 변수 선언</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numStr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// i가 문자열의 길이만큼 증가하는데</span></span><br><span class="line">    answer += <span class="built_in">parseInt</span>(numStr[i]); <span class="comment">// 정답에 자릿수를 앞에서부터 answer에 숫자형태의 값으로 담아서 합을 구함</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> answer; <span class="comment">// 정답 출력</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;문제 설명&lt;/h2&gt;
&lt;p&gt;자연수 N 이 주어지면, N 의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요.&lt;br&gt;
예를들어 N = 123 이면 1 + 2 + 3 = 6 을 return 하면 됩니다.&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://leekeunhwan.github.io/categories/Algorithm/"/>
    
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Algorithm" scheme="https://leekeunhwan.github.io/tags/Algorithm/"/>
    
      <category term="Programmers" scheme="https://leekeunhwan.github.io/tags/Programmers/"/>
    
      <category term="JavaScript" scheme="https://leekeunhwan.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 알고리즘 풀이 - 콜라츠 추측</title>
    <link href="https://leekeunhwan.github.io/2018/08/03/programmers-Collatz-Guess/"/>
    <id>https://leekeunhwan.github.io/2018/08/03/programmers-Collatz-Guess/</id>
    <published>2018-08-03T11:46:57.000Z</published>
    <updated>2018-08-03T12:09:31.438Z</updated>
    
    <content type="html"><![CDATA[<h2>문제 설명</h2><p>1937 년 Collatz 란 사람에 의해 제기된 이 추측은,<br>입력된 수가 짝수라면 2 로 나누고, 홀수라면 3 을 곱하고 1 을 더한 다음,<br>결과로 나온 수에 같은 작업을 1 이 될 때까지 반복할 경우<br>모든 수가 1 이 된다는 추측입니다.</p><p>예를 들어, 입력된 수가 6 이라면 6→3→10→5→16→8→4→2→1 이 되어<br>총 8 번 만에 1 이 됩니다.<br>입력된 수가 몇 번 만에 1 이 되는지 반환하는 함수, solution 을 완성해 주세요.</p><p>단, 500 번을 반복해도 1 이 되지 않는다면 –1 을 반환해 주세요.</p><br><h2>제한 사항</h2><p>입력된 수, num 은 1 이상 8000000 미만인 정수입니다.</p><h2>입출력 예</h2><p>n result<br>6 8<br>16 4<br>626332 -1</p><h3>입출력 예 설명</h3><p>입출력 예 #1<br>문제의 설명과 같습니다.</p><p>입출력 예 #2<br>16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1 이되어 총 4 번만에 1 이 됩니다.</p><p>입출력 예 #3<br>626331 은 500 번을 시도해도 1 이 되지 못하므로 -1 을 리턴해야합니다.</p><h2>문제 풀이</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 정답을 담을 변수 선언</span></span><br><span class="line">  <span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 500번을 반복해봐서 1이 나오면 횟수인 i의 값을 정답으로 1이 안나오면 -1을 정답으로 하면 된다.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// num이 1이면</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 정답은 i</span></span><br><span class="line">      answer = i;</span><br><span class="line">      <span class="comment">// 정답 출력</span></span><br><span class="line">      <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// num이 홀수면 num은 홀수일때의 식을 짝수면 짝수일 때의 식을 실행한다.</span></span><br><span class="line">    num % <span class="number">2</span> ? (num = num * <span class="number">3</span> + <span class="number">1</span>) : (num /= <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 500번 다 돌아도 안나왔으므로 answer는 -1</span></span><br><span class="line">  answer = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 정답 출력</span></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;문제 설명&lt;/h2&gt;
&lt;p&gt;1937 년 Collatz 란 사람에 의해 제기된 이 추측은,&lt;br&gt;
입력된 수가 짝수라면 2 로 나누고, 홀수라면 3 을 곱하고 1 을 더한 다음,&lt;br&gt;
결과로 나온 수에 같은 작업을 1 이 될 때까지 반복할 경우&lt;
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://leekeunhwan.github.io/categories/Algorithm/"/>
    
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Algorithm" scheme="https://leekeunhwan.github.io/tags/Algorithm/"/>
    
      <category term="Programmers" scheme="https://leekeunhwan.github.io/tags/Programmers/"/>
    
      <category term="JavaScript" scheme="https://leekeunhwan.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Uncontrolled_Components (제어되지 않는 컴포넌트)</title>
    <link href="https://leekeunhwan.github.io/2018/08/03/Uncontrolled-Components/"/>
    <id>https://leekeunhwan.github.io/2018/08/03/Uncontrolled-Components/</id>
    <published>2018-08-03T09:15:54.000Z</published>
    <updated>2018-08-03T09:29:15.969Z</updated>
    
    <content type="html"><![CDATA[<h2>Uncontrolled Components</h2><hr><p><code>폼을 구현할 때에는 웬만하면 제어되는 컴포넌트를 사용</code>하시기를 권합니다.<br><code>제어되는 컴포넌트를 사용하면,</code><br><code>폼 데이터가 React 에 의해 적절히 제어될 수 있기 때문</code>입니다.</p><p>반면 <code>제어되지 않는 컴포넌트를 사용하면,</code><br><code>폼 데이터는 DOM 의 자체 기능에 의해 제어</code>됩니다.</p><p><code>제어되지 않는 컴포넌트를 만들 때</code>에는<br><code>상태 업데이트를 위해 이벤트 핸들러를 작성할 필요가 없습니다.</code><br>대신 <code>ref 를 사용해서 폼 데이터를 DOM 으로부터 가져올 수 있습니다.</code></p><p>예를 들어, 아래 코드는 제어되지 않는 컴포넌트를 통해 이름을 입력받습니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">"A name was submitted: "</span> + <span class="keyword">this</span>.input.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> ref=&#123;input =&gt; (<span class="keyword">this</span>.input = input)&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>제어되지 않는 컴포넌트는 진리의 원천을 DOM 에 두기 때문에,</code><br><code>React 를 사용한 코드와 사용하지 않은 코드를</code><br><code>통합하는 작업을 좀 더 쉽게 만들어줄 수 있습니다.</code><br>그리고 <code>코드의 양이 상대적으로 적습니다.</code></p><p>좀 지저분하지만 빠른 해결책을 원한다면 제어되지 않는 컴포넌트를 사용하세요.<br>그렇지 않다면, 제어되는 컴포넌트를 사용하세요.</p><p>아직 어떤 상황에서 무엇을 써야하는지 명확히 감이 오지 않는다면,<br><a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/" style="color:salmon;" target="_blank" rel="noopener">제어되는 input 과 제어되지 않는 input 에 대한 글</a>이 도움이 될 수 있습니다.</p><br><h2>기본값 지정하기</h2><p><code>React 의 렌더링 라이프사이클에서는,</code><br><code>폼 엘리먼트에 지정된 value 어트리뷰트가 DOM 의 값을 덮어쓸 것</code>입니다.</p><p>반면 <code>제어되지 않는 컴포넌트를 사용할 때,</code><br><code>DOM 의 상태변화는 제어되지 않는 상태로 두면서도</code><br><code>초기값을 지정해주어야 하는 경우</code>가 있습니다.</p><p><code>이런 경우를 위해, defaultValue 어트리뷰트를 value 대신 사용할 수 있습니다.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Name:</span><br><span class="line">        &lt;input</span><br><span class="line">          defaultValue=<span class="string">"Bob"</span></span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>비슷하게 <code>&lt;input type=&quot;checkbox&quot;&gt;</code>와 <code>&lt;input type=&quot;radio&quot;&gt;</code> 엘리먼트는<br><code>defaultChecked 어트리뷰트</code>를, <code>&lt;select&gt;</code>와 <code>&lt;textarea&gt;</code>는<br><code>defaultValue 어트리뷰트</code>를 지원합니다.</p><br><h2>The file input Tag</h2><p>HTML 에서, <code>&lt;input type=&quot;file&quot;&gt;</code> 태그는<br>서버에 업로드하거나 처리가 필요한 하나 이상의 파일을<br>기기 저장소에서 선택하는 데 사용되며,<br>이는 File API 를 통해 JavaScript 로 구현됩니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"file"</span> /&gt;</span><br></pre></td></tr></table></figure><p>React 에서 <code>&lt;input type=&quot;file&quot; /&gt;</code>는 <code>언제나 제어되지 않는 컴포넌트</code>인데,<br>왜냐하면 <code>이 엘리먼트의 값은 오로지 사용자에 의해서만 지정될 수 있기 때문</code>입니다.<br>(즉, 프로그래밍을 통해서 지정하는 것이 불가능)</p><p><code>입력받은 파일과 상호작용하기 위해서는 File API 를 사용</code>해야만 합니다.<br>아래 예제는 submit 이벤트 핸들러 내에서 파일에 접근하기 위해<br>DOM node 를 가리키는 ref 를 생성하는 방법을 보여줍니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    alert(<span class="string">`Selected file - <span class="subst">$&#123;<span class="keyword">this</span>.fileInput.files[<span class="number">0</span>].name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Upload file:</span><br><span class="line">          &lt;input</span><br><span class="line">            type=<span class="string">"file"</span></span><br><span class="line">            ref=&#123;input =&gt; &#123;</span><br><span class="line">              <span class="keyword">this</span>.fileInput = input;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;br /</span>&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">FileInput</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;Uncontrolled Components&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;폼을 구현할 때에는 웬만하면 제어되는 컴포넌트를 사용&lt;/code&gt;하시기를 권합니다.&lt;br&gt;
&lt;code&gt;제어되는 컴포넌트를 사용하면,&lt;/code&gt;&lt;br&gt;
&lt;code&gt;폼 
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Uncontrolled Component" scheme="https://leekeunhwan.github.io/tags/Uncontrolled-Component/"/>
    
  </entry>
  
  <entry>
    <title>Context</title>
    <link href="https://leekeunhwan.github.io/2018/08/03/Context/"/>
    <id>https://leekeunhwan.github.io/2018/08/03/Context/</id>
    <published>2018-08-03T08:32:22.000Z</published>
    <updated>2018-08-03T09:06:54.633Z</updated>
    
    <content type="html"><![CDATA[<h2>Context</h2><p>Context 를 사용하면 일일이 props 를 내려보내주지 않아도<br>데이터를 컴포넌트 트리 아래쪽으로 전달할 수 있습니다.</p><hr><p><code>전형적인 React 어플리케이션</code>에서,<br><code>데이터는 props 를 통해 위에서 아래로 (부모에서 자식으로) 전달</code>됩니다.</p><p>하지만 이런 방식은 몇몇 유형의 props 에 대해서는<br>굉장히 번거로운 방식일 수 있습니다. (예를 들어 언어 설정, UI 테마 등)<br>어플리케이션의 많은 컴포넌트들에서 이를 필요로 하기 때문입니다.<br><code>Contetxt 를 사용하면 prop 을 통해 트리의 모든 부분</code>에<br><code>직접 값을 넘겨주지 않고도, 값을 공유</code>할 수 있습니다.</p><br><h2>언제 Context 를 사용해야 할까요?</h2><p>Context 는 React 컴포넌트 트리 전체에 걸쳐<br>데이터를 공유하기 위해 만들어졌습니다.<br>그러한 데이터로는 로그인 된 사용자의 정보, 테마, 언어 설정 등이 있을 수 있겠죠.</p><p>예를 들어, 아래 코드에서는 Button 컴포넌트의 스타일링을 위해<br>“theme” prop 을 일일이 엮어주고 있습니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Toolbar theme="dark" /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Toolbar(props) &#123;</span><br><span class="line">  // Toolbar 컴포넌트에서 별도의 "theme" prop을 받아서</span><br><span class="line">  // ThemedButton 컴포넌트에 이를 넘겨주어야 합니다.</span><br><span class="line">  // 만약 앱에서 사용되는 모든 버튼에 theme prop을 넘겨주어야 한다면</span><br><span class="line">  // 이는 굉장히 힘든 작업이 될 것입니다.</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton theme=&#123;props.theme&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ThemedButton(props) &#123;</span><br><span class="line">  return &lt;Button theme=&#123;props.theme&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Context 를 사용</code>하면,<br>중간 계층에 위치하는 <code>엘리먼트에 props 를 넘겨주는 작업을 피할 수 있습니다</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context를 사용하면 prop을 일일이 엮어주지 않고도</span></span><br><span class="line"><span class="comment">// 컴포넌트 트리의 깊은 곳에 값을 넘겨줄 수 있습니다.</span></span><br><span class="line"><span class="comment">// 테마에 대한 context를 만들어줍시다. ("light"를 기본값으로 합니다.)</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">"light"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// Provider를 사용해서 현재 테마를 트리 아래쪽으로 넘겨줍시다.</span></span><br><span class="line">    <span class="comment">// 어떤 컴포넌트든 이 값을 읽을 수 있습니다. 아주 깊은 곳에 위치해있더라도 말이죠.</span></span><br><span class="line">    <span class="comment">// 아래에서는, "dark"라는 값을 넘겨주었습니다.</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=<span class="string">"dark"</span>&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 이제 더이상 중간 계층에 있는 컴포넌트에서</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ theme prop을 넘겨줄 필요가 없습니다.</span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ThemedButton(props) &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 테마 context를 읽어오려면 Consumer를 사용하세요.</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ React는 가장 가까운 Provider를 찾아서 그 값을 사용할 것입니다.</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 이 예제에서, theme 값은 "dark"가 됩니다.</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">      &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /</span>&gt;&#125;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br><h2>API</h2><h3>React.createContext</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure><p><code>{ Provider, Consumer } 쌍을 만듭니다.</code><br><code>React 가 context Consumer 를 렌더링</code>하면,<br><code>같은 context 로부터 생성된 가장 가까운 상위 Provider 에서</code><br><code>현재 context 의 값을 읽어옵니다.</code></p><p><code>defaultValue 인수는 오직 상위에 같은 context 로부터</code><br><code>생성된 Provider 가 없을 경우에만 사용</code>됩니다.</p><p><code>이 기능을 통해 Provider 없이도</code><br><code>컴포넌트를 손쉽게 테스트</code>해볼 수 있습니다.</p><p>주의: <code>Provider 에서 undefined 를 넘겨줘도</code><br><code>Consumer 에서 defaultValue 를 사용되지는 않습니다.</code></p><br><h3>Provider</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider value=&#123;<span class="comment">/* some value */</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p><code>Context 의 변화를 Consumer 에게 통지하는 React 컴포넌트</code>입니다.</p><p><code>value prop 을 받아서 이 Provider 의 자손인</code><br><code>Consumer 에서 그 값을 전달</code>합니다.<br><code>하나의 Provider 는 여러 Consumer 에 연결될 수 있습니다.</code><br>그리고 <code>Provider 를 중첩해서 트리의 상위에서 제공해준 값을 덮어쓸 수 있습니다.</code></p><br><h3>Consumer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Consumer&gt;</span><br><span class="line">  &#123;value =&gt; <span class="comment">/* render something based on the context value */</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/Consumer&gt;</span></span><br></pre></td></tr></table></figure><p><code>Context 의 변화를 수신하는 React 컴포넌트</code>입니다.</p><p><code>function as a child 패턴을 사용</code>합니다.<br>함수는 <code>현재 context 의 값을 받아서 React 노드를 반환</code>해야 합니다.<br><code>트리 상위의 가장 가까이 있는 Provider 의 value prop 이 이 함수에 전달</code>됩니다.<br><code>만약 트리 상위에 Provider 가 없다면,</code><br><code>createContext()에 넘겨진 defaultValue 값이 대신 전달</code>됩니다.</p><p><code>Provider 의 자손인 모든 Consumer 는</code><br><code>Provider 의 value prop 이 바뀔 때마다 다시 렌더링</code>됩니다.<br><code>이는 shouldComponentUpdate 의 영향을 받지 않으므로,</code><br><code>조상 컴포넌트의 업데이트가 무시된 경우라 할지라도 Consumer 는 업데이트될 수 있습니다.</code></p><p><code>Object.is</code> 메소드를 통해 이전 값과 새 값을 비교함으로써 value prop 이 바뀌었는지를 결정합니다.</p><br><h2>Example - 값이 변하는 Context</h2><p>theme-context.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext(</span><br><span class="line">  themes.dark <span class="comment">// default value</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>themed-button.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ThemeContext &#125; <span class="keyword">from</span> <span class="string">"./theme-context"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;theme =&gt; (</span><br><span class="line">        &lt;button &#123;...props&#125; style=&#123;&#123; <span class="attr">backgroundColor</span>: theme.background &#125;&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default ThemedButton;</span></span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ThemeContext, themes &#125; <span class="keyword">from</span> <span class="string">"./theme-context"</span>;</span><br><span class="line"><span class="keyword">import</span> ThemedButton <span class="keyword">from</span> <span class="string">"./themed-button"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThemedButton를 사용하는 중간 계층의 컴포넌트입니다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;ThemedButton onClick=&#123;props.changeTheme&#125;&gt;Change Theme&lt;/ThemedButton&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      theme: themes.light</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.toggleTheme = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        theme: state.theme === themes.dark ? themes.light : themes.dark</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// ThemeProvider 내부의 ThemedButton은</span></span><br><span class="line">    <span class="comment">// state에 저장되어 있는 theme을 사용하는 반면, 바깥에서는</span></span><br><span class="line">    <span class="comment">// 기본값으로 설정된 dark 테마가 사용됩니다.</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Page&gt;</span><br><span class="line">        &lt;ThemeContext.Provider value=&#123;<span class="keyword">this</span>.state.theme&#125;&gt;</span><br><span class="line">          &lt;Toolbar changeTheme=&#123;<span class="keyword">this</span>.toggleTheme&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Section&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ThemedButton /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Section&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Page&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.root);</span><br></pre></td></tr></table></figure><br><br><h2>Example - 중첩된 컴포넌트에서 context 갱신하기</h2><p><code>컴포넌트 트리의 깊은 곳에 위치한 컴포넌트에서</code><br><code>context 의 값을 갱신해야 하는 경우</code>가 종종 있습니다.</p><p>이런 경우 <code>함수를 아래로 넘겨주어 consumer 가</code><br><code>context 의 값을 갱신하게 만들 수 있습니다</code></p><p>theme-context.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createContext에 넘겨주는 기본값의 모양이</span></span><br><span class="line"><span class="comment">// 실제 consumer에서 사용되는 값과 일치하도록 신경써주세요!</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext(&#123;</span><br><span class="line">  theme: themes.dark,</span><br><span class="line">  toggleTheme: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>theme-toggler-button.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ThemeContext &#125; <span class="keyword">from</span> <span class="string">"./theme-context"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeTogglerButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ThemeTogglerButton 컴포넌트는 theme 뿐만 아니라</span></span><br><span class="line">  <span class="comment">// toggleTheme 함수도 받고 있습니다.</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;(&#123; theme, toggleTheme &#125;) =&gt; (</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;toggleTheme&#125;</span><br><span class="line">          style=&#123;&#123; <span class="attr">backgroundColor</span>: theme.background &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          Toggle Theme</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ThemeTogglerButton;</span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ThemeContext, themes &#125; <span class="keyword">from</span> <span class="string">"./theme-context"</span>;</span><br><span class="line"><span class="keyword">import</span> ThemeTogglerButton <span class="keyword">from</span> <span class="string">"./theme-toggler-button"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.toggleTheme = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        theme: state.theme === themes.dark ? themes.light : themes.dark</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state가 갱신 함수도 포함하고 있기 때문에, 갱신함수 역시</span></span><br><span class="line">    <span class="comment">// provider로 넘겨질 것입니다.</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      theme: themes.light,</span><br><span class="line">      toggleTheme: <span class="keyword">this</span>.toggleTheme</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 전체 state를 provider에 넘겨줍니다.</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Content() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemeTogglerButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.root);</span><br></pre></td></tr></table></figure><br><br><h2>Example - 여러 context 에서 값 넘겨받기</h2><p>각 consumer 를 별도의 노드로 만들어줄 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Theme context, default to light theme</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">"light"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signed-in user context</span></span><br><span class="line"><span class="keyword">const</span> UserContext = React.createContext(&#123;</span><br><span class="line">  name: <span class="string">"Guest"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; signedInUser, theme &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// App 컴포넌트에서 context 값을 제공하고 있습니다.</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;</span><br><span class="line">        &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt;</span><br><span class="line">          &lt;Layout /&gt;</span><br><span class="line">        &lt;<span class="regexp">/UserContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Sidebar /&gt;</span><br><span class="line">      &lt;Content /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 하나의 컴포넌트에서 여러 context의 값을 가져올 수 있습니다.</span></span><br><span class="line"><span class="regexp">function Content() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">      &#123;theme =&gt; (</span></span><br><span class="line"><span class="regexp">        &lt;UserContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">          &#123;user =&gt; &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /</span>&gt;&#125;</span><br><span class="line">        &lt;<span class="regexp">/UserContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>둘 이상의 context 가 자주 함께 사용</code>된다면,<br><code>이를 묶은 render prop 컴포넌트를 만드는 것을 고려</code>해볼 수도 있습니다.</p><br><h2>라이프사이클 메소드에서 context 에 접근하기</h2><p><code>라이프사이클 메소드에서 context 값을 사용해야 하는 경우</code>가 있습니다.<br>이 때에는 <code>값을 prop 으로 넘겨준 뒤, 일반적인 prop 을 다루듯이 다루면 됩니다.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// ThemeContext value is this.props.theme</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// Previous ThemeContext value is prevProps.theme</span></span><br><span class="line">    <span class="comment">// New ThemeContext value is this.props.theme</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; theme, children &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> &lt;button className=&#123;theme ? "dark" : "light"&#125;&gt;&#123;children&#125;&lt;/button&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> props =&gt; (</span><br><span class="line">  &lt;ThemeContext.Consumer&gt;</span><br><span class="line">    &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125;</span><br><span class="line">  &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><br><h2>Context 주의사항</h2><p><code>Context 는 consumer 를 다시 렌더링해야하는 시점을 결정하기 위해</code><br><code>값의 참조가 동일한지를 비교</code>하기 때문에, <code>provider 의 부모가 렌더링될 때</code><br><code>consumer 가 불필요하게 다시 렌더링되는 문제가 생길 수 있습니다.</code></p><p>예를 들어, 아래 코드는 Provider 가 다시 렌더링될 때<br>모든 consumer 를 다시 렌더링시키는데,<br>이는 value 에 매번 새로운 객체가 넘겨지기 때문입니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;&#123; <span class="attr">something</span>: <span class="string">"something"</span> &#125;&#125;&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>이 문제를 회피하려면, value 로 사용할 객체를 부모의 state 에 저장</code>하세요</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: &#123; <span class="attr">something</span>: <span class="string">"something"</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;<span class="keyword">this</span>.state.value&#125;&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br><p><strong style="color:salmon;">[ Context : 꼭 알아야 하는 두가지 교훈]</strong></p><ol><li><p>최상위 컴포넌트에서 최하위 컴포넌트로 손쉽게 데이터나 함수 를 내릴 수 있다.</p></li><li><p>외부세계의 역할만을 책임지는 콤포넌트를 만듦으로써<br>유지보수성을 높일 수 있다.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;Context&lt;/h2&gt;
&lt;p&gt;Context 를 사용하면 일일이 props 를 내려보내주지 않아도&lt;br&gt;
데이터를 컴포넌트 트리 아래쪽으로 전달할 수 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;전형적인 React 어플리케이션&lt;/code&gt;에서,&lt;b
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Context API" scheme="https://leekeunhwan.github.io/tags/Context-API/"/>
    
      <category term="Provider" scheme="https://leekeunhwan.github.io/tags/Provider/"/>
    
      <category term="Consumer" scheme="https://leekeunhwan.github.io/tags/Consumer/"/>
    
  </entry>
  
  <entry>
    <title>Ref_&amp;_DOM</title>
    <link href="https://leekeunhwan.github.io/2018/08/03/Ref-DOM/"/>
    <id>https://leekeunhwan.github.io/2018/08/03/Ref-DOM/</id>
    <published>2018-08-03T08:12:55.000Z</published>
    <updated>2018-08-03T08:20:15.028Z</updated>
    
    <content type="html"><![CDATA[<h2>Ref 와 DOM</h2><hr><p><code>Ref 는 render 메소드에서 생성된 DOM 노드 혹은</code><br><code>React 엘리먼트 객체에 접근할 수 있는 방법을 제공</code>합니다.</p><p><code>전형적인 React 데이터 흐름</code>에서는,<br><code>부모 컴포넌트에서 자식 엘리먼트를 조작하기 위해 props 만을 사용</code>합니다.<br>즉, <code>자식 엘리먼트를 수정하기 위해 새 prop 을 가지고 다시 렌더링을 해줍니다.</code></p><p>하지만 가끔은 전형적인 데이터 흐름 밖에서<br>자식을 명령형으로 변경해야 할 필요가 있습니다.<br>여기서 변경될 자식이란 React 컴포넌트의 인스턴스일 수도 있고,<br>DOM 엘리먼트일 수도 있습니다.<br>React 는 양쪽 경우 모두를 위한 비상구를 제공합니다.</p><p><strong style="color:salmon">언제 ref 를 사용해야 하나요?</strong></p><p>Ref 의 바람직한 사용 사례로 다음과 같은 것을 들 수 있습니다</p><ul><li>포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때</li><li>명령형 애니메이션을 발동시킬 때</li><li>서드파티 DOM 라이브러리를 통합할 때</li></ul><p><code>선언적으로 할 수 있는 작업에 대해서는 ref 의 사용을 피하세요.</code></p><p>예를 들어, Dialog 컴포넌트에 open()과 close()라는<br>메소드를 두는 대신 isOpen 과 같은 prop 을 넘겨주세요.</p><p><code>Ref 의 남용은 금물입니다</code></p><p>여러분의 앱에 “어떤 일이 일어나게”하기 위해<br>ref 를 사용하는 쪽으로 마음이 기울 수 있습니다.</p><p>이 때에는, 잠시 작업을 멈추고 앱의 상태를 컴포넌트 계층의<br>어떤 부분에서 소유해야 하는지를 다시 한 번 생각해보세요.<br>많은 경우, 상태를 “소유”해야 할 적절한 장소는<br>계층의 상위에 있는 컴포넌트라는 결론이 날 것입니다.</p><br><h2>Ref 생성하기</h2><p><code>Ref</code> 는 <code>React.createRef()</code>를 통해 생성한 뒤<br>React 엘리먼트의 ref 어트리뷰트에 붙여줄 수 있습니다.</p><p><strong style="color:salmon">Ref 는 대개 컴포넌트의 인스턴스가 만들어질 때<br>인스턴스의 속성에 저장해주며, 컴포넌트 내부 코드에서 자유롭게 사용</strong><br>될 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><br><br><h2>Ref 사용하기</h2><p>render 메소드에서 반환하는 엘리먼트에 ref 가 넘겨지면,<br>ref 의 <code>current</code> 속성을 통해 해당 노드에 접근할 수 있게 됩니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="keyword">this</span>.myRef.current;</span><br></pre></td></tr></table></figure><p>ref 의 값은 노드의 유형에 따라 달라집니다<br></p><ul><li><p><strong style="color:salmon">HTML 엘리먼트</strong>에 <strong style="color:salmon">ref 어트리뷰트가 사용</strong>되면,<br><strong style="color:salmon">ref 의 current 속성은 DOM 엘리먼트 객체</strong>를 가리킵니다.</p></li><li><p><strong style="color:salmon">클래스 컴포넌트</strong>에 <strong style="color:salmon">ref 어트리뷰트</strong>가 사용되면,<br><strong style="color:salmon">ref 의 current 속성은 해당 컴포넌트로부터 생성된 인스턴스</strong>를 가리킵니다.</p></li><li><p><strong style="color:salmon">함수형 컴포넌트</strong>는 <strong style="color:salmon">인스턴스를 가질 수 없기 때문</strong>에<br><strong style="color:salmon">ref 어트리뷰트 역시 사용할 수 없습니다.</strong></p></li></ul><br><h2>DOM 엘리먼트에 ref 사용하기</h2><p>아래 코드에서는 DOM 노드를 참조하기 위해 ref 를 사용하고 있습니다:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// input DOM 엘리먼트에 접근하기 위해 ref를 만들었습니다.</span></span><br><span class="line">    <span class="keyword">this</span>.textInput = React.createRef();</span><br><span class="line">    <span class="keyword">this</span>.focusTextInput = <span class="keyword">this</span>.focusTextInput.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    <span class="comment">// DOM API를 사용해서 명시적으로 input에 포커스를 두는 코드입니다.</span></span><br><span class="line">    <span class="comment">// 주의: "current" 속성을 사용해 DOM 노드에 접근하고 있습니다.</span></span><br><span class="line">    <span class="keyword">this</span>.textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// &lt;input&gt; ref와 `textInput`이 연결되어 있다는 사실을</span></span><br><span class="line">    <span class="comment">// React한테 알려줍니다.</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.textInput&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"Focus the text input"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>Reaect 는 컴포넌트가 마운트되면<br>textInput 의 current 속성에 DOM 엘리먼트 객체를 할당하며,<br>언마운트가 되었을 때 다시 null 로 되돌릴 것입니다.</p><p><code>ref 의 갱신은 componentDidMount 와</code><br><code>componentDidUpdate 라이프사이클 훅 직전에 일어납니다.</code></p><br><h2>클래스 컴포넌트에 ref 사용하기</h2><p>아래 코드에서는 CustomTextInput 을 감싼 새 컴포넌트를 만들어서<br>마운트 되자마자 포커스가 이동하도록 했습니다.</p><p>여기서는 CustomTextInput 인스턴스에 접근하기 위해<br>ref 를 사용했고 focusTextInput 을 직접 호출해 주었습니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.textInput = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.textInput.current.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CustomTextInput</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>주의할 점은, CustomTextInput 가<br><code>클래스로 선언되었을 때만 이 코드가 동작한다는 점</code>입니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2>Ref 와 함수형 컴포넌트</h2><p><code>함수형 컴포넌트는 인스턴스를 가질 수 없기 때문</code>에<br><code>ref 어트리뷰트 역시 사용할 수 없습니다</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunctionalComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class Parent extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  constructor(props) &#123;</span></span><br><span class="line"><span class="xml">    super(props);</span></span><br><span class="line"><span class="xml">    this.textInput = React.createRef();</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    // 이 코드는 동작하지 않습니다!</span></span><br><span class="line">    return &lt;MyFunctionalComponent ref=&#123;this.textInput&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ref 를 사용하기 위해서는 컴포넌트를 클래스로 바꾸어주어야 합니다.</code><br><code>라이프사이클 메소드나 state 를 사용해야 할 때처럼</code> 말이죠.</p><p>다만, <code>DOM 엘리먼트가 클래스 컴포넌트의 인스턴스에 접근하기 위해</code><br><code>함수형 컴포넌트 안에서 ref 어트리뷰트를 사용하는 것은 얼마든지 가능</code>합니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// textInput은 반드시 여기에서 선언되어야 합니다.</span></span><br><span class="line">  <span class="keyword">let</span> textInput = React.createRef();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> ref=&#123;textInput&#125; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;input type=<span class="string">"button"</span> value=<span class="string">"Focus the text input"</span> onClick=&#123;handleClick&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;Ref 와 DOM&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;Ref 는 render 메소드에서 생성된 DOM 노드 혹은&lt;/code&gt;&lt;br&gt;
&lt;code&gt;React 엘리먼트 객체에 접근할 수 있는 방법을 제공&lt;/code&gt;합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;전형
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Ref" scheme="https://leekeunhwan.github.io/tags/Ref/"/>
    
      <category term="DOM" scheme="https://leekeunhwan.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>Lift_State (State 끌어올리기)</title>
    <link href="https://leekeunhwan.github.io/2018/08/03/Lift-State/"/>
    <id>https://leekeunhwan.github.io/2018/08/03/Lift-State/</id>
    <published>2018-08-03T07:34:05.000Z</published>
    <updated>2018-08-03T07:56:32.649Z</updated>
    
    <content type="html"><![CDATA[<h2>State 끌어올리기</h2><hr><p>종종, <code>하나의 데이터에 대한 변경사항</code>을<br><code>여러 개의 컴포넌트에 반영</code>해야 할 필요가 있습니다.<br>이럴 때는 <code>가장 가까운 공통 조상에 state 를 끌어올리는 걸 권장</code>합니다.</p><p>주어진 온도에서 물이 끓을지 안 끓을지 계산해주는 계산기를 만들어 볼 것입니다.</p><p>BoilingVerdict 라는 컴포넌트를 가지고 시작해보도록 하겠습니다.<br>이 컴포넌트는 celsius(섭씨)라는 prop 을 받아서,<br>이 온도가 물을 끓이기에 충분히 높은지를 출력합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BoilingVerdict</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props.celsius &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The water would boil.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The water would not boil.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음으로, Calculator 라는 컴포넌트를 만들어 보겠습니다.<br>이 컴포넌트는 <code>&lt;input&gt;</code>을 렌더링해서 사용자가 기온을 입력할 수 있게 해 주며,<br>그 값을 <code>this.state.temperature</code>에 저장합니다.</p><p>또, 현재 입력 값에 대한 BoilingVerdict 를 렌더링 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">temperature</span>: <span class="string">""</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">temperature</span>: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> Celsius:<span class="xml"><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span></span><br><span class="line">        &lt;input value=&#123;temperature&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;BoilingVerdict celsius=&#123;<span class="built_in">parseFloat</span>(temperature)&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br><br><h2>두 번째 Input 추가하기</h2><p>우리의 새 요구사항은, 섭씨 온도 외에도<br>화씨 온도에 대한 입력 필드를 추가하고 이 둘을 동기화시키는 것입니다.</p><p>Calculator 컴포넌트에서 TemperatureInput 을 빼내는 것으로 시작해 보겠습니다.<br>또한 “c” 혹은 &quot;f&quot;의 값을 가질 수 있는 scale 이라는 prop 을 추가할 것입니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scaleNames = &#123;</span><br><span class="line">  c: <span class="string">"Celsius"</span>,</span><br><span class="line">  f: <span class="string">"Fahrenheit"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">temperature</span>: <span class="string">""</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">temperature</span>: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> &#123;scaleNames[scale]&#125;:<span class="xml"><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span></span><br><span class="line">        &lt;input value=&#123;temperature&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>이제 두 개의 분리된 기온 입력 필드를 렌더링하도록<br>Calculator 를 바꾸어 보겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput scale=<span class="string">"c"</span> /&gt;</span><br><span class="line">        &lt;TemperatureInput scale=<span class="string">"f"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>이제 우리에겐 두 개의 입력 필드가 있습니다.<br>하지만 한 쪽에서 기온을 입력하면, 다른 쪽이 갱신되지 않습니다.<br>“동기화가 되어야 한다”는 요구사항을 충족시키지 못하고 있군요.</p><p>또한 Calculator 로부터 BoilingVerdict 를 출력하지도 못하고 있습니다.<br>Calculator 는 현재 입력된 기온을 알 수 없는데,<br>그 값이 TemperatureInput 안에 숨겨져 있기 때문입니다.</p><br><h2>변환 함수 작성하기</h2><hr><p>먼저, 섭씨를 화씨로 바꿔주는 함수,<br>또 그 반대의 변환을 해 주는 함수를 작성해보도록 하겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toCelsius</span>(<span class="params">fahrenheit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((fahrenheit - <span class="number">32</span>) * <span class="number">5</span>) / <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFahrenheit</span>(<span class="params">celsius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (celsius * <span class="number">9</span>) / <span class="number">5</span> + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 두 함수는 숫자를 변환합니다.<br>이제 또 다른 함수, 그러니까 temperature 문자열과 변환 함수를<br>인자로 받아서 문자열을 반환하는 함수도 작성해보도록 하겠습니다.</p><p>이 함수는 한 입력 필드로부터 받은 입력값을 가지고<br>다른 필드에 출력할 값을 계산하기 위한 목적으로 사용될 것입니다.</p><p>이 함수는 올바르지 않은 temperature 에 대해서 빈 문자열을 반환하고,<br>소수점 아래 세 번째 자리로 반올림을 합니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryConvert</span>(<span class="params">temperature, convert</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="built_in">parseFloat</span>(temperature);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(input)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> output = convert(input);</span><br><span class="line">  <span class="keyword">const</span> rounded = <span class="built_in">Math</span>.round(output * <span class="number">1000</span>) / <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> rounded.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예를 들어, tryConvert(‘abc’, toCelsius) 는 빈 문자열을 반환하고,<br>tryConvert(‘10.22’, toFahrenheit) 는 ‘50.396’ 을 반환합니다.</p><br><h2>State 끌어올리기</h2><hr><p>지금은 두 <code>TemperatureInput 컴포넌트</code>가<br><code>각각의 입력 필드의 값을 각자의 state 에 독립적으로 저장</code>하고 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">temperature</span>: <span class="string">''</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">temperature</span>: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>하지만, 우리는 이 두 입력 필드가 동기화되기를 원합니다.<br>그러니까 섭씨 입력 필드를 변경하면,<br>그에 따라 화씨 입력 필드도 방금 변경된 기온을 반영해야 합니다.<br>그 반대도 마찬가지입니다.</p><p><code>React 에서는, 특정 state 를 필요로 하는 컴포넌트들의 가장 가까운 공통 조상으로</code><br>해당 <code>state 를 옮김으로써 상태의 공유</code>를 이루어냅니다.<br>이런 기법을 <code>“상태 끌어올리기”</code>라고 부릅니다.</p><p>이제 TemperatureInput 에 있는 지역 상태를 제거하고<br>그 것을 Calculator 로 옮길 것입니다.<br>Calculator 가 공유 상태를 갖게 되면,<br>이는 두 기온 입력 필드에 대한 “진리의 원천(source of truth)“이 됩니다.</p><p>이를 통해 두 입력 필드가 서로에 대한 일관성을 갖게 만들 수 있습니다.<br>두 TemperatureInput 컴포넌트의 props 는<br>같은 부모인 Calculator 로부터 온 것이기 때문에,<br>두 입력 필드가 항상 동기화됩니다.</p><p>먼저, TemperatureInput 컴포넌트의 this.state.temperature 를<br>this.props.temperature 로 바꿀 것입니다.</p><p>일단 this.props.temperature 가 주어져있다고 가정하겠습니다.<br>이것은 나중에 Calculator 로부터 건네받을 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// Before: const temperature = this.state.temperature;</span></span><br><span class="line">  <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>우리는 <code>props 가 읽기 전용</code>이라는 사실을 알고 있습니다.<br><code>temperature 가 지역 상태였을 때</code>는, 이를 <code>변경하기 위해</code><br><code>TemperatureInput 의 this.setState()를 호출하는 것으로 충분</code>했습니다.</p><p>하지만 지금은 <code>temperature 가 부모로부터 주어진 prop 이기 때문</code>에,<br><code>TemperatureInput 로서는 이를 변경할 방법이 없습니다.</code></p><p><code>React 에서는 보통 “통제된” 컴포넌트를 만드는 식으로 이를 해결</code>합니다.<br><code>&lt;input&gt;</code> 요소가 value 와 onChange prop 을 받듯이,<br>우리가 만든 TemperatureInput 도 <code>부모인 Calculator</code> 로부터<br><code>temperature 와 onTemperatureChange prop 들을 받게 할 수 있습니다.</code></p><p>이제, TemperatureInput 에서 기온을 변경해야 할 필요가 생기면<br>this.props.onTemperatureChange 를 호출하면 됩니다:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleChange(e) &#123;</span><br><span class="line">  <span class="comment">// Before: this.setState(&#123;temperature: e.target.value&#125;);</span></span><br><span class="line">  <span class="keyword">this</span>.props.onTemperatureChange(e.target.value);</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><br><p><strong style="color:salmon">[주의]</strong><br><br>temperature 혹은 onTemperatureChange 와 같은<br><code>prop 이름이 특별한 의미를 갖는 것은 아닙니다.</code></p><p>여러분이 원하는 어떤 이름이든 사용할 수 있습니다.<br>value 나 onChange 와 같이 흔히 사용되는 이름도 포함해서 말입니다.</p><p>부모 컴포넌트인 Calculator 는<br>onTemperatureChange 와 temperature prop 을 제공할 것입니다.<br>이를 이용해 그 자신의 지역 상태를 변경하고,<br>변경된 새 값을 이용해 두 입력 필드를 다시 렌더링하게 될 것입니다.<br>새 Calculator 의 구현체는 조금 뒤에 살펴보도록 하겠습니다.</p><p>Calculator 의 변경 사항을 보기 전에,<br>TemperatureInput 컴포넌트의 변경 사항을 살펴보겠습니다.<br>지역 상태가 제거되었고, this.state.temperature 대신<br>this.props.temperature 읽어오도록 했습니다.<br>이제 상태의 변경을 일으키기 위해 this.setState()을 호출하는 대신,<br>Calculator 가 제공한 this.props.onTemperatureChange()을 호출합니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> &#123;scaleNames[scale]&#125;:<span class="xml"><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span></span><br><span class="line">        &lt;input value=&#123;temperature&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>다시 Calculator 컴포넌트로 돌아와봅시다.</p><p><code>입력 필드의 temperature 와 scale 을</code><br>이 <code>컴포넌트의 지역 상태에 저장</code>할 것입니다.<br>이 것이 <code>우리가 입력 필드로부터 “끌어 올린” 상태</code>이며,<br>두 입력 필드의 “진리의 원천” 역할을 하게 될 것입니다.</p><p>또한 이것은 두 입력 필드를 렌더링하기 위해<br>우리가 알아야 할 모든 데이터에 대한 가장 단순한 표현이기도 합니다.</p><p>예를 들어, 섭씨 입력 필드에 37 을 입력하게 되면<br>Calculator 컴포넌트의 state 는 아래와 같이 될 것입니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  temperature: <span class="string">'37'</span>,</span><br><span class="line">  scale: <span class="string">'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>화씨 입력 필드의 값을 212 로 고치면, Calculator 의 상태는 아래와 같이 될 것입니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  temperature: <span class="string">'212'</span>,</span><br><span class="line">  scale: <span class="string">'f'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두 입력 필드의 값을 모두 저장할 수도 있겠지만 이는 불필요합니다.<br>가장 최근에 변경된 입력 필드의 값과 그 단위를 저장하는 것만으로 충분합니다.<br>temperature 와 scale 을 가지고<br>다른 입력 필드의 값을 계산해낼 수 있기 때문입니다.</p><p>두 입력 필드는 완벽히 동기화 되는데, <code>모두 같은 state 로부터 계산되기 때문</code>입니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleCelsiusChange = <span class="keyword">this</span>.handleCelsiusChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleFahrenheitChange = <span class="keyword">this</span>.handleFahrenheitChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">temperature</span>: <span class="string">""</span>, <span class="attr">scale</span>: <span class="string">"c"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleCelsiusChange(temperature) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">scale</span>: <span class="string">"c"</span>, temperature &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleFahrenheitChange(temperature) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">scale</span>: <span class="string">"f"</span>, temperature &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.state.scale;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">const</span> celsius =</span><br><span class="line">      scale === <span class="string">"f"</span> ? tryConvert(temperature, toCelsius) : temperature;</span><br><span class="line">    <span class="keyword">const</span> fahrenheit =</span><br><span class="line">      scale === <span class="string">"c"</span> ? tryConvert(temperature, toFahrenheit) : temperature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=<span class="string">"c"</span></span><br><span class="line">          temperature=&#123;celsius&#125;</span><br><span class="line">          onTemperatureChange=&#123;<span class="keyword">this</span>.handleCelsiusChange&#125;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=<span class="string">"f"</span></span><br><span class="line">          temperature=&#123;fahrenheit&#125;</span><br><span class="line">          onTemperatureChange=&#123;<span class="keyword">this</span>.handleFahrenheitChange&#125;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;BoilingVerdict celsius=&#123;<span class="built_in">parseFloat</span>(celsius)&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>이제, 여러분이 어떤 입력 필드를 수정하든,<br>Calculator 의 this.state.temperature 와 this.state.scale 는 갱신됩니다.</p><p>한 입력 필드는 있는 그대로의 입력값을 받기 때문에<br>사용자가 입력한 값이 보존될 것이고, 다른 입력 필드의 값은<br>앞에서 입력받은 값을 토대로 계산될 것입니다.</p><p>여러분이 입력 필드를 수정할 때 일어나는 일을 전체적으로 살펴보겠습니다.</p><ul><li><p>React 는 <code>&lt;input&gt;</code>에 지정된 onChange 함수를 호출합니다.<br>우리의 경우, TemperatureInput 컴포넌트의 handleChange 함수에 해당합니다.</p></li><li><p>TemperatureInput 컴포넌트의 handleChange 메소드는<br>새로 입력된 값을 가지고 this.props.onTemperatureChange()를 호출합니다.<br>onTemperatureChange 을 포함한 prop 들은<br>부모 컴포넌트인 Calculator 로부터 받은 것입니다.</p></li><li><p>Calculator 안에서 섭씨 TemperatureInput 에 지정된<br>onTemperatureChange 는 Calculator 의 handleCelsiusChange 메소드이며,<br>화씨 TemperatureInput 에 지정된 onTemperatureChange 는<br>Calculator 의 handleFahrenheitChange 메소드입니다.<br>따라서 이 두 Calculator 의 메소드들 중 어떤 메소드가 호출될 지는<br>우리가 어떤 입력 필드를 수정하느냐에 따라 결정됩니다.</p></li><li><p>이 두 메소드의 내부에서는 우리가 방금 수정한 입력 필드에<br>새롭게 입력된 값과 해당 입력 필드의 단위를 가지고<br>this.setState()를 호출함으로써,<br>React 로 하여금 Calculator 를 다시 렌더링하도록 하고 있습니다.</p></li><li><p>React 는 UI 를 어떻게 렌더링할 지를 알아내기 위해<br>Calculator 컴포넌트의 render 메소드를 호출합니다.<br>두 입력 필드의 값이 현재 기온 및 활성화된 단위를 기반으로 다시 계산됩니다.<br>기온의 단위 변환이 여기서 일어납니다.</p></li><li><p>React 는 Calculator 가 준 새로운 props 를 가지고<br>각 TemperatureInput 컴포넌트의 render 를 호출합니다.<br>그럼으로써 UI 가 어떻게 생겼는지를 알아냅니다.</p></li><li><p>React DOM 은 DOM 을 변경합니다.<br>우리가 수정했던 입력 필드는 값을 잘 받고,<br>다른 입력 필드는 변환된 기온으로 갱신됩니다.</p></li></ul><p>입력 필드를 수정할 때마다 같은 과정을 거치게 되고,<br>따라서 두 입력 필드는 동기화 된 상태를 유지합니다.</p><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// full code review</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scaleNames에 c는 화씨, f는 섭씨를 의미함을 객체형식의 값으로 저장</span></span><br><span class="line"><span class="keyword">const</span> scaleNames = &#123;</span><br><span class="line">  c: <span class="string">"Celsius"</span>,</span><br><span class="line">  f: <span class="string">"Fahrenheit"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 화씨를 섭씨로 바꿔주는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toCelsius</span>(<span class="params">fahrenheit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((fahrenheit - <span class="number">32</span>) * <span class="number">5</span>) / <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 섭씨를 화씨로 바꿔주는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFahrenheit</span>(<span class="params">celsius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (celsius * <span class="number">9</span>) / <span class="number">5</span> + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 온도를 받아서 conver 시켜주는 함수 (temperature는 값이고, convert는 함수이다.)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryConvert</span>(<span class="params">temperature, convert</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="built_in">parseFloat</span>(temperature); <span class="comment">// 소수점 버리기</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(input)) &#123;</span><br><span class="line">    <span class="comment">// input의 값이 NaN이면</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">// 아무것도 리턴하지 않는다.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> output = convert(input); <span class="comment">// input의 값이 NaN이 아니면 convert 함수안에 input을 인자로 넣어서 함수 실행</span></span><br><span class="line">  <span class="keyword">const</span> rounded = <span class="built_in">Math</span>.round(output * <span class="number">1000</span>) / <span class="number">1000</span>; <span class="comment">// 반올림 시켜준다.</span></span><br><span class="line">  <span class="keyword">return</span> rounded.toString(); <span class="comment">// 반올림한 것을 문자열로 변환하여 리턴</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BoilingVerdict</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props.celsius &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// props.celsius가 100도 이상이면</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The water would boil.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>; <span class="comment">//  물이 끓는다 반환</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The water would not boil.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>; <span class="comment">// 100도 이상이 안되면 물이 안끓는다 반환</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 온도를 입력하는 역할을 하는 클래스</span></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="comment">// handleChange함수는 입력된 값을 받아서 onTemperatureChange라는 TemperatureInput의 props로 사용</span></span><br><span class="line">    <span class="keyword">this</span>.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature; <span class="comment">// temperature도 props로 사용</span></span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale; <span class="comment">// scale도 props로 사용</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &#123;<span class="comment">/* scale이 c면 celsius, f면 fahrenheit */</span>&#125;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> &#123;scaleNames[scale]&#125;:<span class="xml"><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span></span><br><span class="line">        &lt;input value=&#123;temperature&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Calculator extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 온도를 계산하는 용도의 class</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);</span></span><br><span class="line"><span class="regexp">    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);</span></span><br><span class="line"><span class="regexp">    this.state = &#123; temperature: "", scale: "c" &#125;;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 초기 state 설정</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleCelsiusChange(temperature) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 섭씨로 state를 바꿔주기 위한 장치</span></span><br><span class="line"><span class="regexp">    this.setState(&#123; scale: "c", temperature &#125;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleFahrenheitChange(temperature) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/화씨로 state를 바꿔주기 위한 장치</span></span><br><span class="line"><span class="regexp">    this.setState(&#123; scale: "f", temperature &#125;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    const scale = this.state.scale; /</span><span class="regexp">/ scale은 state의 scale</span></span><br><span class="line"><span class="regexp">    const temperature = this.state.temperature; /</span><span class="regexp">/ temperature는 state의 temperature</span></span><br><span class="line"><span class="regexp">    const celsius =</span></span><br><span class="line"><span class="regexp">      scale === "f" ? tryConvert(temperature, toCelsius) : temperature; /</span><span class="regexp">/ scale이 f이면 섭씨로 바꿔주고 c이면 섭씨가 맞기에 바로 온도를 값으로 할당</span></span><br><span class="line"><span class="regexp">    const fahrenheit =</span></span><br><span class="line"><span class="regexp">      scale === "c" ? tryConvert(temperature, toFahrenheit) : temperature; /</span><span class="regexp">/ scale이 c이면 화씨로 바꿔주고 f이면 화씨가 맞기에 바로 온도를 값으로 할당</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ TempertaureInput 컴포넌트를 화씨와 섭씨 두개 렌더 + 물이 끓는지 않끓는지 알려주는 계산 componenet 렌더</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;TemperatureInput</span></span><br><span class="line"><span class="regexp">          scale="c"</span></span><br><span class="line"><span class="regexp">          temperature=&#123;celsius&#125;</span></span><br><span class="line"><span class="regexp">          onTemperatureChange=&#123;this.handleCelsiusChange&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=<span class="string">"f"</span></span><br><span class="line">          temperature=&#123;fahrenheit&#125;</span><br><span class="line">          onTemperatureChange=&#123;<span class="keyword">this</span>.handleFahrenheitChange&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;BoilingVerdict celsius=&#123;<span class="built_in">parseFloat</span>(celsius)&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Calculator /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br><span class="line"><span class="comment">// Calculator Component index.html에서 렌더</span></span><br></pre></td></tr></table></figure><br><img src="https://github.com/leekeunhwan/Moong2s-TIL/raw/master/image/react-devtools-state.gif" width="550"><br><br><h2>교훈</h2><hr><p><code>React 애플리케이션 안에서 수정되는 데이터</code>에 대해서는<br>반드시 <code>하나의 “진리의 원천”만을 두는 것이 좋습니다.</code><br><code>보통의 경우 state 는 그를 필요로 하는 컴포넌트에 처음으로 작성</code>됩니다.<br>그러고 나서 <code>다른 컴포넌트 역시 그것을 필요로 하게 되면,</code><br><code>가장 가까운 공통 조상에 state 를 끌어올리세요.</code><br>여러 컴포넌트의 state 를 일치시키려고 하지 마시고,<br>대신 <code>하향식 데이터 흐름을 사용</code>하세요.</p><p><code>state 를 끌어올린다는 것</code>은 양방향 바인딩 접근법보다<br>더 많은 “boilerplate” 코드를 작성하는 것을 의미하지만,<br><code>버그를 찾아내거나 격리시키는 작업을 쉽게 만든다는 장점</code>도 있습니다.</p><p><code>어떤 state 든 간에 state 는 컴포넌트 안에 존재</code>하며<br><code>state 를 변경할 수 있는 존재는 오로지 자신 뿐이기 때문</code>에,<br>버그가 존재할 수 있는 범위가 굉장히 좁아지게 됩니다.</p><p>또한, <code>사용자의 입력을 변환하거나 거부하는 자체 로직</code>을<br><code>자유롭게 구현</code>할 수도 있습니다.</p><p><code>어떤 값이 prop 이나 state 로부터 계산될 수 있다면,</code><br><code>그 값은 state 에 두지 않는 것이 좋습니다.</code><br>예를 들어, celsiusValue 와 fahrenheitValue 를 모두 저장하는 대신,<br>우리는 최근에 수정된 temperature 와 그 scale 을 저장했습니다.<br>다른 입력 필드의 값은 언제나 render() 안에서<br>앞의 두 값을 이용해 계산해 낼 수 있습니다.<br>이 방식을 통해 사용자 입력의 정밀도를 잃지 않으면서도<br>다른 필드의 값에 반올림을 적용할 수 있게 됩니다.</p><p><code>만약 UI 가 이상하게 보인다면,</code><br><code>React Developer Tools 를 이용해 props 를 검사</code>하고<br><code>state 의 변경을 담당하는 컴포넌트를 발견할 때까지 따라 올라가보세요.</code><br>이렇게 함으로써 버그의 진원지를 찾아낼 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;State 끌어올리기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;종종, &lt;code&gt;하나의 데이터에 대한 변경사항&lt;/code&gt;을&lt;br&gt;
&lt;code&gt;여러 개의 컴포넌트에 반영&lt;/code&gt;해야 할 필요가 있습니다.&lt;br&gt;
이럴 때는 &lt;code&gt;가장 가까운 공통 조상에 
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Lift State" scheme="https://leekeunhwan.github.io/tags/Lift-State/"/>
    
  </entry>
  
  <entry>
    <title>Form (리액트에서의 Form)</title>
    <link href="https://leekeunhwan.github.io/2018/08/02/Form/"/>
    <id>https://leekeunhwan.github.io/2018/08/02/Form/</id>
    <published>2018-08-02T08:48:14.000Z</published>
    <updated>2018-08-03T09:34:47.746Z</updated>
    
    <content type="html"><![CDATA[<h2>폼</h2><hr><p>HTML 폼(form) 요소는 그 자체가 내부 상태를 가지기 때문에,<br><code>React 에서는 다른 DOM 요소들과는 조금 다르게 동작</code>합니다.<br>예를 들어, 순수한 HTML 에서 이 폼은 이름을 입력받습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    Name:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위 폼에서 유저가 폼을 전송(submit)하면,<br>새로운 페이지로 이동하는 기본 HTML 폼 동작을 수행합니다.<br>만약 React 에서 똑같은 동작을 원한다면, 그냥 그렇게 사용하면 됩니다.</p><p>그러나 대부분의 경우, 자바스크립트 함수를 만들어서<br>form 제출을 처리하고 사용자가 form 에 입력한 데이터에 접근하도록<br>만드는 게 좋습니다. 이를 위해 널리 사용되는 방식은<br><code>“제어되는 컴포넌트 (Controlled Components)“</code>를 사용하는 것입니다.</p><br><h2>제어되는 컴포넌트 (Controlled Components)</h2><hr><p>HTML 에서 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, <code>&lt;select&gt;</code> 같은 form 요소는<br>자기만의 상태를 가지고 사용자의 입력에 따라 업데이트됩니다.</p><p>반면에 React 에서는, <code>변경 가능한 상태</code>를<br>일반적으로 <code>컴포넌트의 state 속성에 위치</code>시키며,<br>이는 <code>setState()로만 업데이트</code>할 수 있습니다.</p><p>React state 를 <code>“진리의 유일한 원천 (single source of truth)“</code>으로<br>만들어 <code>두 세계를 결합</code>할 수 있습니다.<br>(<strong style="color:salmon;">single source of truth</strong> : 모든 state 가 한 곳에 있음을 뜻합니다.)</p><p>이렇게 하면 <code>사용자의 입력에 따라 폼에서 발생되는 일</code>을<br><code>React 컴포넌트 측에서 제어</code>하게 됩니다.</p><p>이런 방식으로, <code>React 에 의해 제어되는 input 폼 요소</code>를<br><code>“제어되는 컴포넌트”</code> 라고 부릅니다.</p><p>위 예제를 바꾸어서 폼이 전송될 때 이름을 출력하기 위해,<br>폼을 제어되는 컴포넌트로 만들어주었습니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react에서는 input 태그 안에 value를 &#123;this.state.value&#125;라고 명시하며 사용합니다.</span></span><br><span class="line"><span class="comment">// input의 value 어트리뷰트를 임의의 값으로 변경하면 react는 input의 value를 편집할 수 없도록 작동합니다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: <span class="string">""</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: event.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">"A name was submitted: "</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input</span><br><span class="line">            type=<span class="string">"text"</span></span><br><span class="line">            value=&#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>value 어트리뷰트가 폼 요소에 설정</code>되었기 때문에,<br><code>표시되는 값은 항상 this.state.value</code> 가 됩니다.</p><p>즉, <code>React state 가 진리의 유일한 원천</code>이 됩니다.</p><p>키 입력이 일어날 때마다 handleChange 가 동작하고<br>React state 가 업데이트되므로,<br>표시되는 값은 사용자의 입력에 따라 업데이트됩니다.</p><p><code>제어되는 컴포넌트를 사용</code>하면<br><code>모든 state 변경과 연관되는 핸들러 함수</code>가 생깁니다.<br>이를 통해 사용자 입력을 수정하거나 검증하는 것이 간단해집니다.</p><p>예를 들어 모든 유저의 이름을 강제로 대문자로 받고싶다면<br>handleChange 를 다음과 같이 쓸 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleChange(event) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value.toUpperCase()&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이렇게 글자 수를 제한을 둘수도 있습니다.</span></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value.toUpperCase().slice(<span class="number">0</span>,<span class="number">10</span>)&#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><h2>textarea 태그</h2><p>HTML 에서, <code>&lt;textarea&gt;</code> 요소는 필드 내부의 텍스트를 자식으로서 지정합니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span></span><br><span class="line">  Hello there, this is some text in a text area</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React 에서 <code>&lt;textarea&gt;</code> 는 대신 value 어트리뷰트를 사용합니다.</p><p>이렇게 하면 <code>&lt;textarea&gt;</code> 를 사용하는 폼은<br>한 줄 짜리 입력 필드와 매우 유사하게 작성할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React에서는 초기 state value를 이용하여 손쉽게 작성할 수 있습니다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EssayForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">"Please write an essay about your favorite DOM element."</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: event.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">"An essay was submitted: "</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Essay:</span><br><span class="line">          &lt;textarea value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>this.state.value 를 생성자 함수에서 초기화</code>하기 때문에,<br><code>텍스트를 가진 채로 textarea 를 표시</code>해줄 수 있습니다.</p><br><h2>select 태그</h2><hr><p>HTML 에서, <code>&lt;select&gt;</code> 는 드롭 다운 목록을 만듭니다.<br>예를 들어, 이 HTML 은 과일 드롭 다운 목록을 만듭니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"grapefruit"</span>&gt;</span>Grapefruit<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"lime"</span>&gt;</span>Lime<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span> <span class="attr">value</span>=<span class="string">"coconut"</span>&gt;</span>Coconut<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"mango"</span>&gt;</span>Mango<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Coconut 옵션에 selected 어트리뷰트가 있기 때문에<br>기본적으로 선택되는 걸 주목합시다.</p><p><code>React 에서는</code> selected 어트리뷰트를 사용하는 대신<br><code>select 태그에 value 어트리뷰트를 사용</code>합니다.</p><p>제어되는 컴포넌트를 쓸 때는 이 방식이 더 편한데,<br><code>한 곳에서만 업데이트를 해주면 되기 때문</code>입니다.</p><p>예를 들어 보겠습니다:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlavorForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: <span class="string">"coconut"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: event.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">"Your favorite flavor is: "</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Pick your favorite La Croix flavor:</span><br><span class="line">          &lt;select value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;&gt;</span><br><span class="line">            &lt;option value=<span class="string">"grapefruit"</span>&gt;Grapefruit&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">            &lt;option value="lime"&gt;Lime&lt;/</span>option&gt;</span><br><span class="line">            &lt;option value=<span class="string">"coconut"</span>&gt;Coconut&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">            &lt;option value="mango"&gt;Mango&lt;/</span>option&gt;</span><br><span class="line">          &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>label&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>정리하겠습니다.</p><p>이 방식을 통해 <code>&lt;input type=&quot;text&quot;&gt;</code>, <code>&lt;textarea&gt;</code>, <code>&lt;select&gt;</code><br>모두 비슷하게 동작합니다.</p><p>즉, value 어트리뷰트를 사용해 제어되는 컴포넌트를 구현할 수 있습니다.</p><br><p><strong style="color:salmon">[주의]</strong></p><p><code>select 태그에서 여러 개의 옵션을 사용하고 싶다면,</code><br><code>value 어트리뷰트에 배열을 전달</code>할 수도 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select multiple=&#123;<span class="literal">true</span>&#125; value=&#123;[<span class="string">'B'</span>, <span class="string">'C'</span>]&#125;&gt;</span><br></pre></td></tr></table></figure><br><h2>여러 Input 제어하기</h2><p><code>여러 개의 input 요소를 제어</code>해야할 때,<br>각 <code>요소에 name 속성을 추가</code>하면 <code>event.target.name 값을 기반</code>으로<br><code>핸들러 함수가 무엇을 해야 할지를 결정</code>할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reservation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isGoing: <span class="literal">true</span>,</span><br><span class="line">      numberOfGuests: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleInputChange = <span class="keyword">this</span>.handleInputChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = event.target;</span><br><span class="line">    <span class="keyword">const</span> value = target.type === <span class="string">"checkbox"</span> ? target.checked : target.value;</span><br><span class="line">    <span class="keyword">const</span> name = target.name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Is going:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=<span class="string">"isGoing"</span></span><br><span class="line">            type=<span class="string">"checkbox"</span></span><br><span class="line">            checked=&#123;<span class="keyword">this</span>.state.isGoing&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;br /</span>&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          <span class="built_in">Number</span> <span class="keyword">of</span> guests:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=<span class="string">"numberOfGuests"</span></span><br><span class="line">            type=<span class="string">"number"</span></span><br><span class="line">            value=&#123;<span class="keyword">this</span>.state.numberOfGuests&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input 의 name 에 해당하는 state 키를 업데이트하기 위해<br>ES6 computed property name 문법을 사용하고 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  [name]: value</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>ES5 코드에선 이렇게 작성합니다:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> partialState = &#123;&#125;;</span><br><span class="line">partialState[name] = value;</span><br><span class="line"><span class="keyword">this</span>.setState(partialState);</span><br></pre></td></tr></table></figure><p>또한, <code>setState() 가 자동으로 현재 상태에 객체를 병합</code> 하기 때문에,<br><code>바뀐 부분에 대해서만 setState()를 호출</code>해주면 됩니다.</p><br><h2>제어되는 입력 필드의 Null 값</h2><p><code>제어되는 컴포넌트 의 value prop 값을 지정</code>해주면,<br>개발자가 직접 value prop 을 변경하는 방법 외에는<br><code>사용자가 입력 필드의 값을 변경할 수 있는 방법이 없습니다.</code></p><p><code>value 를 정의했지만 여전히 입력 필드가 수정 가능한 경우</code>라면<br>실수로 <code>value 를 undefined 나 null 로 설정</code>했을 수 있습니다.</p><p>다음 코드는 위와 같은 상황을 보여줍니다.<br>(처음 보이는 input 은 잠겨있지만 약간의 시간이 지난 후 수정 가능하게 바뀝니다)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"hi"</span> /&gt;</span>, mountNode);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">setTimeout(function() &#123;</span></span><br><span class="line">  ReactDOM.render(&lt;input value=&#123;null&#125; /&gt;, mountNode);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><br><h2>제어되는 컴포넌트에 대한 대안책</h2><hr><p>제어되는 컴포넌트를 사용하는 일은 종종 따분할 수 있는데,<br>왜냐하면 <code>데이터를 변경하는 모든 방법에 대한 이벤트 핸들러를 작성</code>해야하고<br><code>또 하나의 React 컴포넌트에 모든 input state 를 전달</code>해야하기 때문입니다.</p><p>기존 <code>코드베이스를 React 로 변경</code>하거나 <code>React 어플리케이션을</code><br><code>React 가 아닌 라이브러리와 통합할 때 이 작업은 성가신 작업</code>일 수 있습니다.<br>이런 상황에서는 입력 폼을 구현하기 위한 대체 기술인<br><a href="https://leekeunhwan.github.io/2018/08/03/Uncontrolled-Components/" style="color:salmon;">제어되지 않는 컴포넌트</a> 를 확인해보세요.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;폼&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;HTML 폼(form) 요소는 그 자체가 내부 상태를 가지기 때문에,&lt;br&gt;
&lt;code&gt;React 에서는 다른 DOM 요소들과는 조금 다르게 동작&lt;/code&gt;합니다.&lt;br&gt;
예를 들어, 순수한 HTML 에서 이 폼은 
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Form" scheme="https://leekeunhwan.github.io/tags/Form/"/>
    
  </entry>
  
  <entry>
    <title>List_&amp;_Key (리스트와 키)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/List-Key/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/List-Key/</id>
    <published>2018-08-01T06:17:52.000Z</published>
    <updated>2018-08-01T07:05:52.942Z</updated>
    
    <content type="html"><![CDATA[<h2>리스트와 키</h2><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> number * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(doubled);</span><br></pre></td></tr></table></figure><p>위의 코드는 map 메소드를 사용하여 numbers 의 각 항목을 2 배로 만들었습니다.<br>React 에서도 비슷한 과정을 통해 요소 목록을 배열로부터 계산해낼 수 있습니다.</p><br><h2>컴포넌트 여러 개를 렌더링하기</h2><p>요소 목록을 만든 뒤에는 중괄호 {} 를 사용하여<br>JSX 에 포함 시키는 것이 가능합니다.</p><p>아래 예제에서는 자바스크립트의 map() 함수를 사용해서<br>numbers 배열을 순회하면서, 각 항목에 대해 <code>&lt;li&gt;</code> 요소를 반환합니다.<br>마지막으로, 결과적으로 얻어낸 요소 배열을 listItems 에 대입합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> &lt;li&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;);</span></span><br></pre></td></tr></table></figure><p>전체 listItems 배열을 <code>&lt;ul&gt;</code> 요소 안에 삽입해서 DOM 에 렌더링 해줄 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>이 코드는 1 부터 5 까지의 숫자로 이루어진 목록을 표시합니다.</p><br><h2>기본적인 목록 컴포넌트</h2><hr><p>여러분은 대개 컴포넌트 안에서 목록을 렌더링하게 됩니다.<br>이전 예제를 리팩토링해서, numbers 배열을 받아<br>ul 을 출력하는 컴포넌트를 만들어봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> &lt;li&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;);</span></span><br><span class="line"><span class="regexp">  return &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이 코드를 실행하면, 목록의 각 항목에 키를 넣어야한다는 경고가 표시됩니다.<br><code>“키(key)“</code>는 <code>요소 목록를 만들 때 포함해야하는 특수한 문자열 속성</code>입니다.<br>다음 섹션에서 키의 중요성에 대해 더 살펴봅니다.</p><p>numbers.map() 안에서 각 항목에 key 를 할당하여 키 관련 경고를 해결해봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">    &lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  ));</span></span><br><span class="line"><span class="regexp">  return &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 메소드에서 반환하는 요소에는 key prop을 꼭 넣어줘야 합니다.</span></span><br><span class="line"><span class="comment">// key prop에서 다만 index를 사용해서는 안됩니다. (사용하나 마나입니다. / index가 바뀌지 않으면서 안정된 식별자가 필요할 경우 index를 넘겨주기도 합니다.)</span></span><br><span class="line"><span class="comment">// key를 주게되면 React는 정확히 어느 요소를 변경해야할지 알게되므로 의도한 대로 작동합니다.</span></span><br><span class="line"><span class="comment">// 하지만 key를 안주면 React는 정확히 어느 요소를 변경해야할지 모르므르 배열의 마지막 요소를 삭제합니다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    numbers: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> numbers = <span class="keyword">this</span>.state.numbers;</span><br><span class="line">    <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number, index</span>) =&gt;</span> (</span><br><span class="line">      &lt;div key=&#123;number&#125;&gt;</span><br><span class="line">        &lt;span&gt;&#123;number&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="text" /</span>&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;e =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">              numbers: numbers.filter(<span class="function">(<span class="params">item, i</span>) =&gt;</span> i !== index)</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          삭제</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><br><h2>키</h2><hr><p><code>키를 지정해주면 어떤 아이템이 바뀌었는지, 추가되었는지,</code><br><code>삭제되었는 지를 React 에게 알려줄 수 있습니다.</code><br>(안알려주면 의도치않게 동작합니다.)<br></p><p>배열에 들어있는 요소마다 식별자를 키로 넣어주세요.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">  &lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br></pre></td></tr></table></figure><p>키로 쓰기에 가장 적절한 값은 각 항목을<br>고유하게 식별할 수 있는 문자열입니다.<br>대부분의 경우 데이터의 ID 를 키로 사용합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.text&#125;&lt;<span class="regexp">/li&gt;);</span></span><br></pre></td></tr></table></figure><p>만약 그러한 값이 없다면, 최후의 수단으로 배열 인덱스를 키로 사용할 수도 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> (</span><br><span class="line">  <span class="comment">// Only do this if items have no stable IDs</span></span><br><span class="line">  &lt;li key=&#123;index&#125;&gt;&#123;todo.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br></pre></td></tr></table></figure><p>항목 간 순서가 바뀔 수 있는 경우 키에 인덱스를 사용하지 않는 게 좋습니다.<br>이로 인해 성능이 저하되거나 컴포넌트의 state 와 관련된 문제가 생길 수 있습니다.</p><p>Robin Pokorny 가 작성한 아티클인<br>[인덱스를 키로 사용할 때의 부정적인 영향에 대한 심층적 설명]<br>(in-depth explanation on the negative impacts of using an index as a key)를<br>참고하시길 바랍니다.</p><p>[<a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" target="_blank" rel="noopener">https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318</a>]</p><p>만약 <code>명시적으로 키를 지정하지 않으면</code><br><code>React 는 기본적으로 인덱스를 키로 사용</code>합니다.<br></p><br><h2>키로 컴포넌트 추출하기</h2><hr><p><code>키는 바로 바깥쪽의 배열에 대해서만 의미</code>를 가집니다.</p><p>예를 들어, ListItem 컴포넌트를 추출 한 경우,<br>ListItem 자체의 루트 <code>&lt;li&gt;</code> 요소가 아닌<br>배열의 <code>&lt;ListItem /&gt;</code> 요소가 키를 가지고 있어야합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 잘못된 키 사용법의 예</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = props.value;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 틀렸습니다! 여기서 키를 넣어주는 것은 아무런 효과가 없습니다.</span></span><br><span class="line">    &lt;li key=&#123;value.toString()&#125;&gt;&#123;value&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function NumberList(props) &#123;</span></span><br><span class="line"><span class="regexp">  const numbers = props.numbers;</span></span><br><span class="line"><span class="regexp">  const listItems = numbers.map(number =&gt; (</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 틀렸습니다! 바로 여기서 키를 넣어주어야 합니다.</span></span><br><span class="line"><span class="regexp">    &lt;ListItem value=&#123;number&#125; /</span>&gt;</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 올바른 키 사용법의 예</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 맞았습니다! 여기서 키를 넣어주는 것이 아닙니다.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.value&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">    <span class="comment">// 맞았습니다! 바로 여기서 키를 넣어주어야 합니다.</span></span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>”map() 에서 반환하는 요소에는 키를 넣어준다”</code>고 외워두어도 좋습니다.</p><br><h2>키는 형제 중에서 고유한 값이어야한다.</h2><hr><p><code>배열 내에서 사용되는 키는 형제 간에 고유해야합니다.</code><br>그러나 <code>전체 범위에서 고유할 필요는 없습니다.</code><br>서로 다른 두 배열을 생성할 때는 동일한 키를 사용할 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Blog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sidebar = (</span><br><span class="line">    &lt;ul&gt;&#123;props.posts.map(<span class="function"><span class="params">post</span> =&gt;</span> &lt;li key=&#123;post.id&#125;&gt;&#123;post.title&#125;&lt;<span class="regexp">/li&gt;)&#125;&lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> content = props.posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">    &lt;div key=&#123;post.id&#125;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;post.title&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;post.content&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ));</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;sidebar&#125;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">      &#123;content&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const posts = [</span></span><br><span class="line"><span class="regexp">  &#123; id: 1, title: "Hello World", content: "Welcome to learning React!" &#125;,</span></span><br><span class="line"><span class="regexp">  &#123; id: 2, title: "Installation", content: "You can install React from npm." &#125;</span></span><br><span class="line"><span class="regexp">];</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Blog posts=&#123;posts&#125; /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p><code>키는 React 에게 힌트를 제공하지만 컴포넌트로 전달되지는 않습니다.</code><br>(역주: 컴포넌트 안에서 this.props.key 와 같이 가져와서 쓰는 것이 불가능)</p><p>만약 <code>컴포넌트에 동일한 값이 필요하다면</code><br><code>명시적으로 다른 이름의 prop 으로 전달</code>하도록 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> content = posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">  &lt;Post key=&#123;post.id&#125; id=&#123;post.id&#125; title=&#123;post.title&#125; /&gt;</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>위 예제에서 Post 컴포넌트는 <a href="http://props.id" target="_blank" rel="noopener">props.id</a> 를 읽을 수 있지만,<br>props.key 는 읽을 수 없습니다.</p><br><br><h2>JSX 에서 map() 포함하기</h2><p>위 예제에서 별도의 listItems 변수를 선언하고 이를 JSX 에 포함시켰습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSX 는 중괄호 안에 임의의 표현식을 포함 할 수 있기 때문에,<br>map() 도 인라인으로 포함시킬 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">        &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>위 스타일을 통해 코드가 더 명확해질 수도 있지만 남용하는 것은 좋지 않습니다.</p><p>자바스크립트와 마찬가지로, 가독성을 위해 변수로 추출해야할지<br>아니면 인라인으로 넣을지는 개발자가 직접 판단해야합니다.</p><p><code>map() 함수가 너무 중첩되어있다면, 컴포넌트로 추출 하는 것이 좋습니다.</code></p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;리스트와 키&lt;/h2&gt;
&lt;hr&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="List" scheme="https://leekeunhwan.github.io/tags/List/"/>
    
      <category term="Key" scheme="https://leekeunhwan.github.io/tags/Key/"/>
    
  </entry>
  
  <entry>
    <title>Conditional_Render (조건부 렌더링)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/Conditional-Render/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/Conditional-Render/</id>
    <published>2018-08-01T04:34:44.000Z</published>
    <updated>2018-08-01T06:17:25.878Z</updated>
    
    <content type="html"><![CDATA[<h2>조건부 렌더링</h2><hr><p>React 에서는, <code>컴포넌트를 만들어서 원하는 동작을 캡슐화</code>할 수 있습니다.<br>그리고 나서, <code>어플리케이션의 상태에 따라 컴포넌트의 일부만 렌더링</code>할 수 있습니다.</p><p>React 의 <code>조건부 렌더링은 자바스크립트의 조건문과 동일한 방식으로 동작</code>합니다.<br>if 나 조건 연산자 같은 자바스크립트 연산자를 사용하여<br>현재 상태를 표현하는 요소를 만들고, 요소에 맞게 UI 를 갱신하세요.</p><p>두 컴포넌트를 살펴봅시다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Welcome back!&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Please sign up.&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자의 로그인 여부에 따라 다음 컴포넌트 중<br>하나를 표시하는 Greeting 컴포넌트를 만들었습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;UserGreeting /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;GuestGreeting /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  // Try changing to isLoggedIn=&#123;true&#125;:</span><br><span class="line">  &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;,</span><br><span class="line">  document.getElementById("root")</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이 예제는 isLoggedIn 의 prop 값에 따라 다른 메시지를 노출시킵니다.</p><br><h2>요소 변수</h2><hr><p><code>요소를 담기 위해 변수를 사용</code>할 수 있습니다.<br>이렇게 하면 다른 부분을 바꾸지 않으면서도<br><code>컴포넌트의 일부를 조건부로 렌더링하기가 쉬워집니다.</code></p><p>로그아웃과 로그인 버튼을 나타내는 두 개의 새 컴포넌트를 살펴봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;props.onClick&#125;&gt;Login&lt;/button&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LogoutButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;props.onClick&#125;&gt;Logout&lt;/button&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서, LoginControl 이라는 stateful 컴포넌트 를 생성했습니다.<br>이 컴포넌트는 현재 상태에 따라 <code>&lt;LoginButton /&gt;</code> 혹은<br><code>&lt;LogoutButton /&gt;</code> 중 하나를 렌더링 할 것입니다.</p><p>이전 예제에서 만들었던 <code>&lt;Greeting /&gt;</code> 도 렌더링합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginControl</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleLoginClick = <span class="keyword">this</span>.handleLoginClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleLogoutClick = <span class="keyword">this</span>.handleLogoutClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isLoggedIn</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLoginClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isLoggedIn</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLogoutClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isLoggedIn</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> button = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 로그인의 변수의 값이 true면</span></span><br><span class="line">    <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">      <span class="comment">// 이거 실행</span></span><br><span class="line">      button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 거짓이면 이거 실행</span><br><span class="line">      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class="line">        &#123;button&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;LoginControl /&gt;, document.getElementById("root"));</span><br></pre></td></tr></table></figure><p>변수를 선언하고 if 문을 사용하는 것은<br>조건부로 컴포넌트를 렌더링하는 훌륭한 방법이지만,<br>원한다면 더 짧은 문법을 사용할 수도 있습니다.</p><p>JSX 에 조건을 인라인으로 넣는 몇가지 방법을 소개합니다.<br></p><br><h2>&amp;&amp; 논리 연산자를 사용해 if 를 인라인으로 넣기</h2><hr><p>중괄호로 감싸면 JSX 에 어떤 표현식이건 넣을 수 있습니다.<br>여기에는 자바스크립트 &amp;&amp; 논리 연산자도 포함됩니다.</p><p>이를 사용하면 요소를 조건부로 포함시키는 작업을 더 편하게 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      &#123;unreadMessages.length &gt; <span class="number">0</span> &amp;&amp; (</span><br><span class="line">        &lt;h2&gt;You have &#123;unreadMessages.length&#125; unread messages.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = [<span class="string">"React"</span>, <span class="string">"Re: React"</span>, <span class="string">"Re:Re: React"</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이 코드는 잘 동작하는데, 자바스크립트에서 true &amp;&amp; expression 은<br>항상 expression 으로 평가되고, false &amp;&amp; expression 은<br>항상 false 로 평가되기 때문입니다.</p><p>따라서 조건이 true 라면 &amp;&amp; 다음에 오는 요소가 노출됩니다.<br>만약 조건이 false 라면, React 는 이를 무시하고 건너뜁니다.</p><br><h2>조건부 연산자를 사용해 if-else 인라인으로 넣기</h2><hr><p>인라인으로 요소를 조건부 렌더링하는 다른 방법은<br>자바스크립트의 조건부 연산자인<br><code>condition ? true : false</code> 를사용하는 것입니다.</p><p>아래 예제에서, 작은 텍스트 블록을 조건부로 렌더링합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      The user is &lt;b&gt;&#123;isLoggedIn ? <span class="string">'currently'</span> : <span class="string">'not'</span>&#125;&lt;<span class="regexp">/b&gt; logged in.</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>좀 지저분하긴 하지만, 어쨌든 큰 표현식에서도 사용할 수는 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLoggedIn ? (</span><br><span class="line">        &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br><br><h2>컴포넌트가 렌더링 되지 못하도록 방지</h2><hr><p>흔하지 않지만 어떤 컴포넌트에 의해 렌더링된<br>컴포넌트를 숨기고 싶은 경우가 있습니다.<br>이렇게 하려면 요소 대신 null 을 반환하면 됩니다.</p><p>아래 예제에서, <code>&lt;WarningBanner /&gt;</code> 는<br>warn prop 의 값에 의존해 렌더링됩니다.<br>만약 prop 값이 false 라면, 이 컴포넌트는 렌더링되지 않습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div className="warning"&gt;Warning!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">showWarning</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleToggleClick = <span class="keyword">this</span>.handleToggleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      showWarning: !prevState.showWarning</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;WarningBanner warn=&#123;<span class="keyword">this</span>.state.showWarning&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.showWarning ? <span class="string">"Hide"</span> : <span class="string">"Show"</span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Page /&gt;, document.getElementById("root"));</span><br></pre></td></tr></table></figure><p>컴포넌트의 render 메서드에서 null 을 반환한다고 해서,<br>컴포넌트의 라이프사이클 메서드 호출 과정에 영향을 미치지는 않습니다.</p><p>예를 들어, componentWillUpdate 와<br>componentDidUpdate 가 여전히 호출됩니다.<br></p><p><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;조건부 렌더링&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;React 에서는, &lt;code&gt;컴포넌트를 만들어서 원하는 동작을 캡슐화&lt;/code&gt;할 수 있습니다.&lt;br&gt;
그리고 나서, &lt;code&gt;어플리케이션의 상태에 따라 컴포넌트의 일부만 렌더링&lt;/code&gt;할 수 있습
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Conditional Render" scheme="https://leekeunhwan.github.io/tags/Conditional-Render/"/>
    
  </entry>
  
  <entry>
    <title>Event_Handling (이벤트 제어하기)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/Event-Handling/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/Event-Handling/</id>
    <published>2018-08-01T03:56:07.000Z</published>
    <updated>2018-08-01T04:43:08.219Z</updated>
    
    <content type="html"><![CDATA[<h2>이벤트 제어하기</h2><hr><p>React 요소의 이벤트를 제어하는 것은<br>DOM 요소 이벤트를 제어하는 것과 매우 유사합니다.</p><p>다만 몇가지 문법적인 차이가 있습니다.</p><ul><li><code>React 이벤트</code>는 소문자 대신 <code>camelCase 를 사용</code>합니다.</li><li><code>JSX 에</code> 문자열 대신 <code>함수를 전달</code>합니다.</li></ul><br><p>예를 들어 HTML 에서 이벤트를 넣을 때는 이렇게 합니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"activateLasers()"</span>&gt;Activate Lasers&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>React 에서는 조금 다릅니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;Activate Lasers&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>다른 차이점으로는 React 에서 기본 동작을 막기 위해<br>false 를 반환할 수 없다는 것입니다.</p><p>반드시 명시적으로 <code>preventDefault()</code> 를 호출해야 합니다.<br>예를 들어 HTML 에서 새로운 페이지를 여는 기본 링크 동작을 막으려면<br>아래와 같이 작성할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#"</span> onclick=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span><br><span class="line">  Click me</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>React 에서는 대신 이렇게 작성합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The link was clicked."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>여기서 e 는 합성 이벤트입니다.<br>React 는 W3C spec 에 따라 이런 합성 이벤트를 정의하므로,<br>브라우저 간 호환성을 걱정할 필요는 없습니다.<br>더 자세한 사항은 <a href="https://reactjs.org/docs/events.html" style="color:salmon;" target="_blank" rel="noopener">SyntheticEvent 레퍼런스 가이드</a>를 보시길 바랍니다.</p><p>React 를 사용할 때, (일반적인 경우) 리스너를 추가하기 위해<br>DOM 요소가 생성된 후 addEventListener 를 호출할 필요가 없습니다.<br>대신 요소를 처음 렌더링할 때 리스너를 같이 넘겨주세요.</p><p>ES6 class 를 이용해 컴포넌트를 정의할 때,<br><code>이벤트 핸들러를 만들기 위해 보통 클래스 메서드를 사용</code>합니다.</p><p>예를 들어, 아래 Toggle 컴포넌트는 “ON” 과 “OFF” state 를<br>유저가 토글할 수 있게 하는 버튼을 렌더링합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 다른 곳에 넘겨주는 함수는 가급적 화살표함수로 만들어서 사용하는 것이 좋습니다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isToggleOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 콜백에서 `this`가 제대로 동작하게 만들려면 아래 바인딩을 꼭 해주어야 합니다.</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="string">"ON"</span> : <span class="string">"OFF"</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Toggle /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>JSX 콜백에서 this 의 의미에 대해 주의해야합니다.<br><code>자바스크립트에서 클래스 메서드는 기본적으로 바인딩 되지 않습니다.</code><br>만약 this.handleClick 바인드를 잊은채로 onClick 에 전달하면,<br>this 는 함수가 실제로 호출될 때 undefined 로 취급됩니다.</p><p>이건 React 에서만 해당되는 동작이 아닙니다.<br>자바스크립트의 함수의 동작 방식 자체가 이렇습니다.<br>일반적으로 onClick={this.handleClick} 처럼 () 없이 메서드를 참조하면,<br>그 <code>메서드를 bind 해야합니다.</code></p><p>만약 bind 를 호출하는 게 귀찮은 경우,<br>이 문제를 해결할 수 있는 두 가지 방법이 있습니다.</p><p>만약 실험적 기능인 <code>퍼블릭 클래스 필드 문법 을 사용하고 있다면,</code><br>콜백을 올바르게 바인딩하기 위해 <code>클래스 필드를 사용할 수 있습니다.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 이 문법은 handleClick 안에서 `this`가 제대로 바인딩됨을 보장합니다.</span></span><br><span class="line">  <span class="comment">// 경고: 이는 *실험적인* 문법입니다.</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"this is:"</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Create React App 을 사용하고 있다면<br>이 문법을 바로 사용할 수 있습니다.</p><p>만약 <code>클래스 필드 문법을 사용하고 싶지 않다면,</code><br><code>콜백에서 arrow function 을 사용</code>할 수도 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"this is:"</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// This syntax ensures `this` is bound within handleClick</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.handleClick(e)&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 문법의 문제점은 LogginButton 을 렌더링할 때마다<br>서로 다른 콜백이 만들어지는 것입니다.</p><p>대부분의 경우에서 크게 문제는 없습니다.</p><p>하지만 <code>하위 컴포넌트에 콜백을 prop 으로서 전달하는 경우,</code><br>이 컴포넌트는 <code>불필요한 렌더링을 더 일으킬 수 있습니다.</code></p><p>이런 종류의 성능 문제를 피하기 위해,<br><code>보통 생섬자 함수에서 바인딩하거나 클래스 필드 문법을 사용하는 걸 권장</code>합니다.</p><br><h2>이벤트 핸들러에 인수 전달하기</h2><hr><p>반복문 안에서 이벤트 핸들러에 추가 파라미터를 전달하고 싶은 경우가 많습니다.<br>예를 들어, 만약 id 가 행 ID 라면, 아래처럼 전달할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure><p>위 두 라인은 동일하며,<br><code>arrow functions</code> 과 <code>Function.prototype.bind</code> 를 각각 사용하고 있습니다.</p><p>두 경우 모두, React 이벤트를 나타내는 e 인수는<br>ID 뒤에 두 번째 인수로 전달됩니다.</p><p><code>arrow function 을 사용하면 ID 를 명시적으로 전달</code>해야 하지만,<br><code>bind 를 사용하면 추가로 넘겨준 인수가 자동으로 전달</code>됩니다.</p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;이벤트 제어하기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;React 요소의 이벤트를 제어하는 것은&lt;br&gt;
DOM 요소 이벤트를 제어하는 것과 매우 유사합니다.&lt;/p&gt;
&lt;p&gt;다만 몇가지 문법적인 차이가 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;React 이벤트
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Event" scheme="https://leekeunhwan.github.io/tags/Event/"/>
    
      <category term="Event Handling" scheme="https://leekeunhwan.github.io/tags/Event-Handling/"/>
    
  </entry>
  
  <entry>
    <title>State_&amp;_Life_Cycle (상태와 라이프사이클)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/State-Life-Cycle/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/State-Life-Cycle/</id>
    <published>2018-08-01T03:31:34.000Z</published>
    <updated>2018-08-01T04:44:14.262Z</updated>
    
    <content type="html"><![CDATA[<h2>State 와 라이프사이클</h2><hr><p>지금까지 우리는 UI 를 업데이트하는 한가지 방법을 배웠습니다.<br>ReactDOM.render() 을 호출하여 렌더링된 출력을 변경합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>이 섹션에서는 재사용가능하고 캡슐화된<br>Clock 컴포넌트를 만드는 방법에 대해 배웁니다.<br>자체 타이머를 설정하고 매 초마다 스스로 업데이트합니다.<br></p><p>시계가 어떻게 보이는 지 캡슐화하는 것부터 시작합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> <span class="attr">date</span>=<span class="string">&#123;new</span> <span class="attr">Date</span>()&#125; /&gt;</span>, document.getElementById("root"));</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">setInterval(tick, 1000);</span></span><br></pre></td></tr></table></figure><p>그러나 중요한 요구사항이 하나 빠져있습니다.<br>Clock 이 타이머를 설정하고 매 초 UI 를 업데이트 하는 것은<br>Clock 의 구현 세부사항이어야 합니다.<br></p><p>이상적으로 Clock 은 한번만 작성하고 자체적으로 업데이트 시키려고 합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>이걸 구현하기 위해, Clock 컴포넌트에 <code>“state”</code>를 추가할 필요가 있습니다.<br>State 는 props 와 비슷하지만 <code>컴포넌트에 의해 완전히 제어되며 private 속성</code>입니다.<br>이전에 언급 했던 대로 클래스로 정의한 컴포넌트에는 몇가지 추가 기능이 있습니다.<br>로컬 state 는 클래스에서만 사용 가능한 기능입니다.</p><br><h2>함수를 클래스로 변환</h2><hr><p>Clock 같은 함수형 컴포넌트를 클래스로 변환하려면 다섯 단계를 진행합니다.</p><ol><li>ES6 class 를 같은 이름으로 만들고, React.Component 를 확장합니다.</li><li>비어있는 render() 메서드를 하나 추가합니다.</li><li>함수의 바디를 render() 메서드 안으로 옮깁니다.</li><li>render() 바디 내에서 props 를 this.props 로 바꿉니다.</li><li>남아있는 빈 함수 선언문을 제거합니다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clock 은 이제 함수 대신 클래스로 정의합니다.<br>이를 통해 로컬 state 나 라이프사이클 훅 같은 추가 기능을 사용할 수 있습니다.</p><br><h2>Class 에 로컬 state 추가하기</h2><hr><p>date 를 props 에서 state 로 옮기기 위해서 세 단계를 진행합니다.</p><ol><li>render() 메서드 내의 this.props.date 를 this.state.date 로 바꿉니다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ol start="2"><li>this.state 를 초기화 하는 클래스 생성자 를 추가합니다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>props 를 기본 생성자에 어떻게 전달하는 지 살펴보길 바랍니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">   <span class="keyword">super</span>(props);</span><br><span class="line">   <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>클래스 컴포넌트는 항상 props 와 함께 기본 생성자를 호출합니다.<br></p><ol start="3"><li><clock> 요소에서 date prop 을 삭제합니다.</clock></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>나중에 타이머 코드를 컴포넌트 자체에 다시 추가합니다.<br>이 결과는 다음과 같은 코드가 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>다음으로, Clock 에 자체 타이머를 설정하고<br>매 초마다 자체적으로 업데이트 하는 걸 만들어봅시다.</p><br><h2>클래스에 라이프사이클 메서드 추가하기</h2><hr><p>많은 컴포넌트를 가진 어플리케이션에서,<br>컴포넌트가 제거될 때 리소스를 풀어주는 건 아주 중요한 일입니다.<br>Clock 이 DOM 에 최초로 렌더링 될 때 타이머를 설정 하려고 합니다.<br>React 에서 이를 <code>mounting</code> 이라고 부릅니다.</p><p>그리고 DOM 에서 Clock 을 삭제했을 때 타이머를 해제 하려고 합니다.<br>React 에서 이를 <code>unmounting</code> 이라고 부릅니다.<br><br>컴포넌트가 마운트 (mount) 되고 언마운트 (unmount) 될 때<br>특정 코드를 실행하기 위해 컴포넌트 클래스에 특별한 메서드를 선언할 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Life Cycle</span></span><br><span class="line"><span class="comment">// Render: componentWillMount() -&gt; render() -&gt; componentDidMount()</span></span><br><span class="line"><span class="comment">// Update componentWillReceiveProps() -&gt; shouldComponentUpdate() -&gt; componentWillUpdate() -&gt; render() -&gt; componentDidUpdate()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 메서드들을 “라이프사이클 훅” 이라고 부릅니다.<br><code>componentDidMount()</code> 훅은 컴포넌트 출력이 DOM 에 렌더링 된 이후 동작합니다.<br>이 부분이 타이머를 설정하기 좋은 지점입니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">    () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this 에 timer ID 를 어떻게 저장하는 지 살펴봅시다.<br></p><p>렌더링과 관련된 데이터 흐름에서, this.props 는 React 에 의해 설정되고<br>this.state 는 특별한 의미를 갖고 있습니다.</p><p>반면 위와 같이 데이터 흐름에 참여하지 않는 무언가를 저장할 때<br>클래스에 직접 필드를 추가하는 것도 가능합니다.</p><p>이제 <code>componentWillUnmount()</code> 라이프사이클 훅에서 타이머를 종료할 것입니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 Clock 컴포넌트에서<br>매 초마다 동작하는 tick() 이라는 메서드를 구현해봅시다.<br></p><p><code>this.setState()</code> 를 사용해서 컴포넌트 로컬 state 에 대한 업데이트를 예약합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 리액트는 최초 렌더를 제외하고는 변화가 있어야 화면을 렌더합니다.</span></span><br><span class="line"><span class="comment">// componentDidMount는 1초마다 tick을 호출하고,</span></span><br><span class="line"><span class="comment">// tick은 state를 변경해줍니다.</span></span><br><span class="line"><span class="comment">// state가 변경되었기에 다시 렌더가 되고,</span></span><br><span class="line"><span class="comment">// 렌더가 완료된 후에 clearInterval이 이루어집니다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 클래스 필드를 사용하면 생성자를 사용하지 않고도 초기 값을 지정할 수 있다.</span></span><br><span class="line">  <span class="comment">// state = &#123; date: new Date() &#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.tick(), <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// tick을 1초에 한번씩 호출하면 setState를 호출하니 화면을 다시 그려주게 되는 셈입니다.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      <span class="comment">//  1. 상태를 바꿔주고, 2. 화면이 간접적으로 다시 그려지도록 해줍니다.</span></span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 상태로 부터 화면이 어떻게 그려져야 하는지를 render 메소드에 서술합니다.</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>이제 시계는 매 초 깜빡입니다.<br>어떤 작업을 했는 지와 메서드가 호출되는 순서를 간단히 요약해봅시다.</p><p><code>&lt;Clock /&gt;</code> 이 <code>ReactDOM.render() 에 전달</code>될 때,<br><code>React 는 Clock 컴포넌트의 생성자 함수를 호출</code>합니다.</p><p>Clock 이 현재 시각을 화면에 보여주어야 하기 때문에,<br>현재 시각을 포함하는 <code>this.state 객체를 초기화</code>합니다.<br>이 <code>state 는 추후 업데이트</code>됩니다.</p><p>React 가 <code>Clock 컴포넌트의 render() 메서드를 호출</code>합니다.<br>이를 통해 React 는 화면에 무엇을 보여줘야 하는지 알아냅니다.<br>그 다음 React 는 <code>DOM 을 갱신해서 Clock 의 렌더링 출력과 일치</code>시킵니다.</p><p><code>Clock 출력이 DOM 에 주입되었을 때,</code><br>React 는 <code>componentDidMount() 라이프 훅을 호출</code>합니다.<br>그 안에서 <code>Clock 컴포넌트는 브라우저에게 컴포넌트의 tick() 메서드를</code><br><code>초당 한 번씩 호출하는 타이머를 설정하라고 명령</code>합니다.</p><p>브라우저에서 매 초마다 tick() 메서드를 호출합니다.<br>그 안에서 Clock 컴포넌트는 현재 시각을 갖고 있는 객체를 가지고<br><code>setState() 를 호출하여 UI 업데이트를 예약</code>합니다.</p><p><code>setState() 호출 덕분에, React 는 상태가 변경</code>된 걸 알게 됐고,<br>(setState()를 호출하면 화면이 다시그려지게 된다는 것도 기억해야 합니다.)<br>render() 메서드를 <code>다시 한 번 호출해 화면에 무엇을 표시</code>해야 할지 알 수 있습니다.<br>이번에는, render() 메서드 내의 <code>this.state.date 가 달라지므로</code><br><code>바뀐 시간이 출력에 포함</code>됩니다. React 는 그에 따라 DOM 을 업데이트합니다.</p><p>만약 <code>Clock 컴포넌트가 DOM 에서 삭제</code>된다면,<br>React 는 <code>componentWillUnmount() 라이프사이클 훅을 호출</code>하기 때문에<br><code>타이머가 멈춥니다.</code></p><br><h2>State 바르게 사용하기</h2><hr><ul><li><b style="color:salmon;">State 를 직접 수정하지 마세요</b></li></ul><p>이 코드는 컴포넌트를 다시 렌더링하지 않습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><p>대신, setState() 를 사용하세요.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">comment</span>: <span class="string">"Hello"</span> &#125;);</span><br></pre></td></tr></table></figure><p><code>this.state 를 할당할 수 있는 유일한 장소는 생성자 함수 내부</code>입니다.</p><ul><li><b style="color:salmon;">State 업데이트는 비동기일 수 있습니다</b></li></ul><p><code>React 는 성능을 위해 여러 setState() 호출을</code><br><code>한 번의 작업으로 묶어서 처리하는 경우</code>가 있습니다.</p><p><code>this.props 및 this.state 가 비동기로 업데이트될 수 있기 때문</code>에,<br>다음 <code>state 를 계산할 때 이 값을 신뢰해서는 안됩니다.</code></p><p>예를 들어, 카운터를 업데이트하는 이 코드는 실패할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이 문제를 해결하기 위해 객체가 아닌<br>함수를 받는 두 번째 형식의 setState() 를 사용할 수 있습니다.</p><p>이 함수는 이전 state 를 첫 번째 인수로 받고,<br>두 번째 인수로 업데이트가 적용 될 때 props 를 받습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이전 상태로부터 새 상태를 계산할 때는 콜백 형식의 setState를 사용해야 합니다.</span></span><br><span class="line"><span class="comment">// 객체를 바로 반환받음에도 중괄호를 괄호로 덮어줘야 합니다. 안그러면 에러가 발생합니다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>위 예제에서는 arrow function 을 사용했지만, 평범한 함수도 동작합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">prevState, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><ul><li><b style="color:salmon;">State 업데이트는 병합됩니다</b></li></ul><p><code>setState() 를 호출할 때, React 는 넘겨받은 객체를 현재 state 에 병합</code>합니다.<br>예를 들어, <code>state 는 여러 독립적인 변수를 가질 수 있습니다.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    posts: [],</span><br><span class="line">    comments: []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런 다음 <code>개별 setState() 를 호출하여 아이템을 각각 업데이트할 수 있습니다.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  fetchPosts().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      posts: response.posts</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fetchComments().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      comments: response.comments</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 때 얕은 병합을 수행하기 때문에, this.setState({comments}) 는<br>this.state.posts 는 그대로 두지만, this.state.comments 는 완전히 대체합니다.</p><ul><li><b style="color:salmon;">데이터는 아래로 흐릅니다</b></li></ul><p><code>부모 컴포넌트나 자식 컴포넌트는 특정 컴포넌트의 state 유무를 알 수 없으며,</code><br><code>해당 컴포넌트가 함수나 클래스로 선언되었는 지 알 수 없습니다.</code><br>이것이 바로 state 가 ‘지역적이다’ 혹은 ‘캡슐화되었다’고 하는 이유입니다.</p><p><code>State 를 지정해 준 컴포넌트 외의 다른 컴포넌트에서는 state 에 접근할 수 없습니다.</code><br>컴포넌트는 자신의 state 를 props 로서 자식 컴포넌트에 내려줄 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br></pre></td></tr></table></figure><p>이는 사용자 정의 컴포넌트에서도 마찬가지로 동작합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedDate date=&#123;<span class="keyword">this</span>.state.date&#125; /&gt;</span><br></pre></td></tr></table></figure><p>FormattedDate 컴포넌트는 props 에서 date 를 받지만<br>이 값이 Clock 의 상태인지, Clock 의 props 인지,<br>혹은 타이핑된 것인지 알 수 없습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedDate</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 데이터 흐름을 보통 <code>“하향식(top-down)”</code> 혹은<br><code>“단방향(unidirectional)” 데이터 흐름</code>이라고 합니다.</p><p><code>모든 state 는 항상 특정 컴포넌트가 가지며,</code><br><code>해당 state 에서 파생된 모든 데이터와</code><br><code>UI 는 트리의 “아래(below)“에 있는 컴포넌트에만 영향을 미칩니다.</code></p><p>컴포넌트 트리를 props 의 폭포라고 상상해보면,<br>각 컴포넌트의 상태는 임의의 지점에서 추가되는<br>물과 비슷하고 또한 아래로 흐릅니다.</p><p>모든 컴포넌트가 실제로 격리되어있음을 보여주기 위해,<br>세 개의 <clock> 을 렌더링하는 App 컴포넌트를 만들어봅시다.</clock></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>각 Clock 은 자체적으로 타이머를 생성하고 독립적으로 바뀝니다.</p><p>React 앱에서, 컴포넌트가 state 를 갖고 있는지(stateful)<br>또는 갖지 않는지(stateless)는 구현 세부 사항으로 간주되어<br>시간이 지남에 따라 바뀔 수 있습니다.</p><p>state 를 가진 컴포넌트 내부에서 state 가 없는 컴포넌트를 사용할 수 있으며,<br>그 반대 경우도 마찬가지입니다.</p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;State 와 라이프사이클&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;지금까지 우리는 UI 를 업데이트하는 한가지 방법을 배웠습니다.&lt;br&gt;
ReactDOM.render() 을 호출하여 렌더링된 출력을 변경합니다.&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="State" scheme="https://leekeunhwan.github.io/tags/State/"/>
    
      <category term="Life Cycle" scheme="https://leekeunhwan.github.io/tags/Life-Cycle/"/>
    
  </entry>
  
  <entry>
    <title>Component_&amp;_Props (컴포넌트와 프롭)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/Component-Props/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/Component-Props/</id>
    <published>2018-07-31T16:21:18.000Z</published>
    <updated>2018-08-01T04:42:55.436Z</updated>
    
    <content type="html"><![CDATA[<h2>컴포넌트와 props</h2><hr><p>컴포넌트를 통해 UI 를 독립적이고 재사용 가능한 부분으로 분리하고,<br>각 부분을 독립적으로 생각할 수 있습니다.<br></p><p>개념상 컴포넌트는 자바스크립트 함수와 비슷합니다.<br>“props”이라 불리는 임의의 입력을 받아들이고,<br>화면에 무엇이 표시되어야 하는지를 서술하는 React 요소를 반환합니다.</p><br><h2>함수형 및 클래스 컴포넌트</h2><hr><p>컴포넌트를 정의하는 가장 간단한 방법은 자바스크립트 함수를 작성하는 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 함수는 유효한 React 컴포넌트로,<br><code>“props”</code> (properties 를 나타냄) 객체 인수를 받고 <code>React 요소를 반환</code>합니다.<br><br>이러한 컴포넌트는 말 그대로 자바스크립트 함수이기 때문에<br><code>“함수형 컴포넌트”</code>라고 부릅니다.<br><br></p><p>컴포넌트를 정의하기 위해 ES6 class 를 사용할 수도 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 두 컴포넌트는 React 관점에서 봤을 때 동일한 기능을 갖습니다.<br></p><p>클래스는 몇가지 기능을 더 가지고 있는데, 이는 다음 섹션 에서 다룹니다.<br>그 때까지 간결함을 유지하기 위해 함수형 컴포넌트를 사용할 것입니다.<br></p><br><h2>컴포넌트 렌더링</h2><hr><p>이전에는 DOM 태그를 나타내는 React 요소만 있었습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;div /&gt;;</span><br></pre></td></tr></table></figure><p>그러나, 는 사용자 정의 컴포넌트를 나타낼 수도 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;Welcome name="Sara" /&gt;;</span><br></pre></td></tr></table></figure><p>React 가 사용자 정의 컴포넌트를 나타내는 요소를 처리할 때는,<br><b style="color:salmon">JSX 어트리뷰트를 하나의 객체를 통해 컴포넌트로 전달</b>합니다.<br>이 객체를 <code>“props”</code> 라고 부릅니다.<br><br></p><p>예를 들어, 이 코드는 “Hello, Sara”를 페이지에 렌더링합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = &lt;Welcome name="Sara" /&gt;;</span><br><span class="line">ReactDOM.render(element, document.getElementById("root"));</span><br></pre></td></tr></table></figure><br><ol><li><p><code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> 요소로 <code>ReactDOM.render()</code> 를 호출합니다.</p></li><li><p>React 가 <code>{name: 'Sara'}</code> 를 props 로 하여 Welcome 컴포넌트를 호출합니다.</p></li><li><p>Welcome 컴포넌트가 그 결과로 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 요소를 반환합니다.</p></li><li><p>React DOM 이 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 과 일치하도록<br>DOM 을 효율적으로 업데이트합니다.<br><br></p></li></ol><p><strong style="color:salmon">[경고]</strong><br><br>컴포넌트 이름은 항상 대문자로 시작하도록 지으세요.<br>(소문자는 html 로 인식합니다.)<br><br>예를 들어 <code>&lt;div /&gt;</code> 는 DOM 태그를 나타내지만<br><code>&lt;Welcome /&gt;</code> 은 컴포넌트를 나타내며 스코프에 Welcome 이 있어야 합니다.<br></p><br><h2>컴포넌트 조립하기</h2><hr><p><strong style="color:salmon">컴포넌트의 출력에서 다른 컴포넌트를 가져와 사용할 수 있습니다.</strong><br>이를 통해 모든 세부 레벨에서 동일한 컴포넌트 추상화를 사용할 수 있습니다.<br>React 앱에서 버튼, 폼, 다이얼로그, 스크린 같은 것들은<br>모두 일반적으로 컴포넌트로 표현됩니다.<br><br></p><p>예를 들어, Welcome 을 여러번 렌더링하는 App 컴포넌트를 만들 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Sara"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Cahal"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Edite"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>일반적으로, 새롭게 작성되는 React 앱은 단일 App 컴포넌트를 최상위에 둡니다.<br>그러나 기존 앱에 React 를 도입하는 경우, Button 같은 작은 컴포넌트부터<br>덩치를 키워나가기 시작하여 점차적으로 뷰 계층의 최상단으로 나아갈 수 있습니다.</p><br><h2>컴포넌트 추출</h2><hr><p>컴포넌트를 더 작은 컴포넌트로 쪼개는 것을 두려워하지 마십시오.<br>예를 들어, Comment 컴포넌트를 살펴봅시다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;img</span><br><span class="line">          className=<span class="string">"Avatar"</span></span><br><span class="line">          src=&#123;props.author.avatarUrl&#125;</span><br><span class="line">          alt=&#123;props.author.name&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;&#123;props.author.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;&#123;props.text&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;&#123;formatDate(props.date)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>이 컴포넌트는 author (객체), text (문자열), date (Date 객체)를 props 로 받고,<br>소셜 미디어 웹사이트의 댓글을 나타냅니다.</p><p>이 컴포넌트는 중첩 때문에 변경하기 까다로울 수 있으며,<br>각 파트를 다시 사용하기도 어렵습니다.<br>여기에서 몇가지 컴포넌트를 추출해봅시다.</p><p>먼저, Avatar 를 추출할 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Avatar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;img className=<span class="string">"Avatar"</span> src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Avatar 는 자기가 Comment 내에서 렌더링되는 지를 알고 있을 필요가 없습니다.<br>따라서 author 대신 user 라는 더 일반적인 이름을 사용합니다.</p><p>속성 이름을 지을 때는,<br>컴포넌트가 사용되는 상황이 아닌 컴포넌트 그 자체만 생각하는 것이 좋습니다.<br></p><p>이제 Comment 를 약간 단순화시킬 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Avatar를 분할한 상태</span></span><br><span class="line"><span class="comment">// Comment의 기능이 많다는 것을 알 수 있습니다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;Avatar user=&#123;props.author&#125; /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;&#123;props.author.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;&#123;props.text&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;&#123;formatDate(props.date)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>이어서, 유저의 이름 옆에 Avartar 를 렌더링하는 UserInfo 컴포넌트를 추출해봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기능 분할 - userInfo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo-name"</span>&gt;&#123;props.user.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 Comment 가 더 단순해졌습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정말 Comment만 남도록 분리해서 단순해졌습니다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;&#123;props.text&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;&#123;formatDate(props.date)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>컴포넌트를 추출하는 건 처음에는 쓸데없는 일처럼 보일 수 있지만,<br>재사용 가능한 컴포넌트 팔레트를 사용하면 큰 앱에서 그 진가를 발휘합니다.</p><p>적당한 기준을 잡아보자면,<br>UI 의 일부분이 여러 번 사용되거나 (Button, Panel, Avatar),<br>자체적으로 충분히 복잡하다면 (App, FeedStory, Comment),<br>그것들은 재사용 가능한 컴포넌트가 될 좋은 후보입니다.</p><br><h2>Props 는 읽기전용입니다</h2><hr><p>컴포넌트를 함수나 클래스 중 어떤 걸로 선언했건,<br>자기 자신의 props 를 수정할 수 없습니다.<br>sum 함수를 살펴봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 함수는 입력을 변경하려 하지 않고,<br><code>동일한 입력에 대해 항상 동일한 결과를 반환하기 때문에 “순수” 함수</code>라고 불립니다.</p><p>위와 반대로, 이 함수는 입력을 변경하기 때문에 순수하지 않습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">account, amount</span>) </span>&#123;</span><br><span class="line">  account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 는 매우 유연하지만 한가지 엄격한 규칙을 갖고 있습니다.<br>모든 React 컴포넌트는 props 에 대해서는 순수 함수처럼 동작해야합니다.<br></p><br><p><strong style="color:salmon">[순수 함수란?]</strong></p><p>함수는 주어진 입력으로 계산하는 것 이외에<br>프로그램의 실행에 영향을 미치지 않아야 합니다. (부수효과 X)<br>이러한 함수를 <code>순수 함수</code>라고 합니다.<br></p><p>예를 들어, count, length 함수는 임의의 문자열이나 배열에 대해서<br>항상 같은 길이를 반환하며, 그 외의 일은 일어나지 않습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func plusNumber(num: Int) -&gt; (Int -&gt; Int) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; x <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> x + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addFive = plusNumber(<span class="number">5</span>)</span><br><span class="line">addFive(<span class="number">1</span>)<span class="comment">// 5</span></span><br><span class="line">addFive(<span class="number">10</span>)<span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>위의 코드에서 익명함수를 만들어 사용하게 되고 어떤 값이 들어오던지<br>5 를 더하여 반환하게 되므로 부수 효과가 발생하지 않습니다.</p><p>순수 함수의 참조 투명성(referential transparency, RT)으로 입력 값이 같으면<br>결과 값도 같다면 표현식은 참조에 투명하다(referentially transparent)라고 합니다.<br>표현식 f(x)가 참조에 투명한 모든 x 에 대해 참조가 투명하다면<br>함수 f 는 순수하다(pure)라고 합니다.</p><p>따라서 <code>코드의 블록을 이해하기 위해 일련의 상태 갱신을 따라갈 필요가 없고 국소 추론(local reasoning)만으로도 코드를 이해</code>할 수 있습니다.</p><p><code>모듈적인 프로그램은 독립적으로 재사용할 수 있는 구성요소(component)로 구성</code>됩니다.</p><p>따라서 순수 함수는 입력과 결과가 분리되어 있으며,<br>어떻게 사용되는지에 대해서는 전혀 신경쓰지 않아도 되므로 재사용성이 높아집니다.</p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;컴포넌트와 props&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;컴포넌트를 통해 UI 를 독립적이고 재사용 가능한 부분으로 분리하고,&lt;br&gt;
각 부분을 독립적으로 생각할 수 있습니다.&lt;br&gt;&lt;/p&gt;
&lt;p&gt;개념상 컴포넌트는 자바스크립트 함수와 비슷합니다.&lt;br&gt;
“
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="Component" scheme="https://leekeunhwan.github.io/tags/Component/"/>
    
      <category term="Props" scheme="https://leekeunhwan.github.io/tags/Props/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Elements_Render (요소 렌더링)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/Elements-Render/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/Elements-Render/</id>
    <published>2018-07-31T15:58:10.000Z</published>
    <updated>2018-08-01T04:43:01.708Z</updated>
    
    <content type="html"><![CDATA[<h2>요소 렌더링</h2><hr><p>요소는 <code>React 앱에서 가장 작은 단위의 재료</code>입니다.<br>요소는 화면에 표시하고자 하는 내용을 서술합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>브라우저 DOM 요소와 달리,<br>React 요소는 순수한 객체이며 생성 비용이 저렴합니다.<br><br>React DOM 라이브러리는 DOM 갱신 작업을 관장하며,<br>React 요소와 DOM 이 일치하도록 만듭니다.<br></p><br><h2>DOM 에서 요소 렌더링하기</h2><hr><p>HTML 파일 어딘가에 <code>&lt;div&gt;</code> 가 있다고 가정해봅시다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React DOM 에 의해 관리되는 모든 것이 이 요소 안에 들어가므로,<br>이걸 <code>“루트” DOM 노드</code>라고 부릅니다.</p><p>React 로 구축한 어플리케이션은 보통 하나의 루트 DOM 노드를 가집니다.<br><br>React 를 기존 앱에 통합하는 경우,<br>원하는 만큼의 여러 루트 DOM 노드를 만들 수도 있습니다.<br><br>React 요소를 루트 DOM 노드에 렌더링하고 싶다면,<br><code>ReactDOM.render()</code> 에 둘 다 넘겨주면 됩니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><br><h2>렌더링된 요소 업데이트</h2><hr><p>React 요소는 변경 불가능 합니다. 한번 요소를 만들었다면,<br>그 자식이나 어트리뷰트를 변경할 수 없습니다.<br>요소는 영화의 단일 프레임에 비유할 수 있습니다.</p><p>즉, 요소는 특정 시점의 UI 를 표현할 뿐입니다.<br><br></p><p>이제까지 배운 것만 가지고 UI 를 갱신할 수 있는 유일한 방법은<br>새로운 요소를 만들어서 이 요소를 <code>ReactDOM.render()</code> 로 전달하는 것입니다.<br></p><p>깜빡이는 시계를 구현한 예제를 살펴봅시다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>이 예제는 <code>setInterval()</code> 콜백을 이용해 매 초마다<br><code>ReactDOM.render()</code> 를 호출하고 있습니다.<br><br>하지만 대부분의 React 어플리케이션은<br><code>ReactDOM.render()</code> 를 <b style="color:salmon;">한 번만</b> 호출합니다<br></p><br><h2>React 는 꼭 필요한 부분만 갱신합니다</h2><hr><p>React DOM 은 요소 및 그 자식을 이전 버전과 비교하고,<br>DOM 을 원하는 상태로 만드는 데 필요한 DOM 업데이트만 적용합니다.<br><strong style="color:salmon;">(Virtual DOM)</strong></p><p>마지막 예제 를 개발자 도구로 관찰해보면 알 수 있습니다.</p><img src="https://github.com/leekeunhwan/Moong2s-TIL/raw/master/image/react_clock.gif" width="400"><p>매 깜빡임마다 전체 UI 트리를 서술하는 요소를 만들었지만,<br>내용이 변경된 텍스트 노드만이 React DOM 에 의해서 업데이트 됩니다.</p><p>우리의 경험상,<br><code>‘시간 경과에 따라 UI 를 어떻게 변경할지’</code>를 생각하는 것이 아니라<br><code>‘특정 순간에 UI 가 어떻게 보여져야 할지’</code>에 대해 생각하면,<br>수많은 종류의 버그를 없앨 수 있습니다.<br></p><p>[Virtual DOM 은 가상의 DOM 으로 실제 DOM 과 비교 알고리즘을 통해<br>변경부분을 파악하고 변경 부분만 렌더링 해줍니다.]<br><br><img src="https://github.com/leekeunhwan/Moong2s-TIL/raw/master/image/virtual_DOM.png" width="500"></p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;요소 렌더링&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;요소는 &lt;code&gt;React 앱에서 가장 작은 단위의 재료&lt;/code&gt;입니다.&lt;br&gt;
요소는 화면에 표시하고자 하는 내용을 서술합니다.&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Elements_Render" scheme="https://leekeunhwan.github.io/tags/Elements-Render/"/>
    
  </entry>
  
  <entry>
    <title>JSX란?</title>
    <link href="https://leekeunhwan.github.io/2018/07/30/JSX/"/>
    <id>https://leekeunhwan.github.io/2018/07/30/JSX/</id>
    <published>2018-07-30T12:49:53.000Z</published>
    <updated>2018-08-01T04:41:51.897Z</updated>
    
    <content type="html"><![CDATA[<h2>JSX 란?</h2><hr><p>JSX 는 자바스크립트의 확장문법으로 JSX 를 리액트와 함께 사용하면<br>UI 가 실제로 어떻게 보일지 서술할 수 있습니다.<br>JSX 는 템플릿 언어처럼 보일 수 있지만 템플릿 언어는 아닙니다.<br>JSX 는 React 요소를 만듭니다.</p><br><h2>왜 JSX 인가?</h2><hr><p>React 는 렌더링 로직이 다른 UI 로직과 본질적으로<br>결합되어 있다는 사실을 인정합니다.</p><p>즉, 이벤트의 처리 과정, 시간에 따른 상태 변화, 표시할 데이터가<br>어디로부터 오는지가 렌더링 로직과 결합되어 있다는 것입니다.</p><p>React 는 별도의 파일에 마크업과 로직을 넣어 기술 을 인위적으로 분리하는 대신,<br>둘 다 포함하는 “컴포넌트”라고 부르는 단위를 이용해 관심사를 분리 합니다.</p><p>React 를 사용하기 위해 반드시 JSX 를 사용해야 하는 것은 아닙니다만,<br>많은 사람들이 자바스크립트 코드 안에서 UI 작업을 할 때<br>시각적으로 더 편하다고 느끼고 있습니다.<br>또한 JSX 를 사용하면 React 가 유용한 에러 및 경고 메시지를 표시해줄 수 있습니다.</p><br><h2>JSX 에 표현식 포함하기</h2><hr><p>JSX 안에 자바스크립트 표현식 을 중괄호로 묶어서 포함시킬 수 있습니다.<br>(JSX 에서 중괄호를 쓰면 중괄호 안에서 자유롭게 자바스크립트를 다룰 수 있습니다.)<br><br>예를 들어, 2 + 2, user.firstName, formatName(user) 를<br>유효한 표현식으로 표현하면 아래와 같이 표현합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">" "</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">"Harper"</span>,</span><br><span class="line">  lastName: <span class="string">"Perez"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>가독성을 좋게 하기 위해 JSX 를 여러줄로 나눴습니다.<br><br>필수는 아니지만, 이 작업을 수행할 때는 자동 세미콜론 삽입의 함정을 피하기 위해<br>괄호로 묶는 것이 좋습니다.</p><br><h2>JSX 또한 표현식이다</h2><hr><p>컴파일이 끝나면, JSX 표현식이 일반적인 자바스크립트 함수 호출이 되고,<br>결과적으로 자바스크립트 객체로 평가됩니다.<br>이 말은 if 문이나 for 문 내에서 JSX 를 사용할 수 있으며,<br>변수에 할당하거나 매개변수로 전달하거나 함수에서 반환할 수 있음을 의미합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2>JSX 어트리뷰트 정의</h2><hr><p>어트리뷰트에서 따옴표를 사용해서 문자열 리터럴을 정의할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>어트리뷰트에 중괄호를 사용하면, 자바스크립트 표현식을 포함시킬 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>어트리뷰트에 자바스크립트 표현식을 포함시킬 때 중괄호를 따옴표로 묶지 마세요.<br>따옴표 (문자열 값인 경우) 또는 중괄호 (표현식인 경우) 중 하나를 사용해야 하며,<br>하나의 어트리뷰트에 둘 다 사용할 수 있는 것이 아닙니다.</p><p><strong stlye="color:salmon">경고</strong></p><p>JSX 는 HTML 보다는 자바스크립트에 가깝기 때문에,<br>React DOM 은 HTML 어트리뷰트 이름 대신<br>camelCase 어트리뷰트 이름 컨벤션을 사용합니다.</p><p>예를 들어, JSX 에서 class 는 <code>className</code> 이 되며, tabindex 는 <code>tabIndex</code> 가 됩니다.</p><br><h3>예를 들면 이렇게</h3><table><thead><tr><th style="text-align:center">HTML Attribute</th><th style="text-align:center">HTML Example</th><th style="text-align:center">JSX Property</th><th style="text-align:center">JSX Example</th></tr></thead><tbody><tr><td style="text-align:center">class</td><td style="text-align:center"><code>&lt;div class='fancy'&gt;...&lt;/div&gt;</code></td><td style="text-align:center">className*</td><td style="text-align:center"><code>&lt;div className='fancy'&gt;...&lt;/div&gt;</code></td></tr><tr><td style="text-align:center">onclick</td><td style="text-align:center"><code>&lt;button onclick=&quot;foo()&quot;&gt;...</code></td><td style="text-align:center">onClick*</td><td style="text-align:center"><code>&lt;button onClick={foo}&gt;...</code><br><code>&lt;button onClick={() =&gt; foo(param)}&gt;...</code></td></tr><tr><td style="text-align:center">tabindex</td><td style="text-align:center"><code>&lt;input tabindex=2 /&gt;</code></td><td style="text-align:center">tabIndex</td><td style="text-align:center"><code>&lt;input tabIndex={2} /&gt;</code></td></tr></tbody></table><br><br><h3>HTML vs Web API vs React JSX</h3><table><thead><tr><th style="text-align:center">Difference</th><th style="text-align:center">HTML</th><th style="text-align:center">Web API</th><th style="text-align:center">React JSX</th></tr></thead><tbody><tr><td style="text-align:center">Names of attributes / properties</td><td style="text-align:center">lower case</td><td style="text-align:center">(mostly) camelCase</td><td style="text-align:center"><strong>camelCase</strong></td></tr><tr><td style="text-align:center">Values of attributes / properties</td><td style="text-align:center">string</td><td style="text-align:center">expression</td><td style="text-align:center">expression within <code>{ }</code></td></tr><tr><td style="text-align:center">Names of event handlers (on…)</td><td style="text-align:center">lower case</td><td style="text-align:center">lower case (!)</td><td style="text-align:center"><strong>camelCase</strong></td></tr><tr><td style="text-align:center">Values of event handlers (on…)</td><td style="text-align:center">JavaScript string</td><td style="text-align:center">function expr.</td><td style="text-align:center">function expr. within <code>{ }</code></td></tr><tr><td style="text-align:center">Event Handlers: prevent default behaviour</td><td style="text-align:center">n/a</td><td style="text-align:center">can return <code>false</code></td><td style="text-align:center">must call <code>event.preventDefault();</code></td></tr><tr><td style="text-align:center">HTML Tags</td><td style="text-align:center">lower case</td><td style="text-align:center">n/a*</td><td style="text-align:center">lower case</td></tr><tr><td style="text-align:center">Custom Tags (Components)</td><td style="text-align:center">n/a</td><td style="text-align:center">n/a</td><td style="text-align:center">start with <strong>capital letter</strong></td></tr></tbody></table><br><br><h2>JSX 자식 정의</h2><hr><p>만약 태그가 비어있다면, XML 처럼 /&gt; 를 이용해 닫아주어야 합니다. (빈태그 문법)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>JSX 태그는 자식을 가질 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><h2>JSX 인젝션 공격 예방</h2><hr><p>사용자가 입력한 내용을 JSX 내에 포함시켜도 안전합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>기본적으로, React DOM 은 렌더링 되기 전에<br>JSX 내에 포함된 모든 값을 이스케이프 합니다.</p><p>따라서 어플리케이션에 명시적으로 작성되지 않은 내용은 절대 삽입할 수 없습니다.<br>모든 것은 렌더링 되기 전에 문자열로 변환됩니다.<br>이렇게 하면 XSS (cross-site-scripting) 공격을 막을 수 있습니다.</p><br><h2>JSX 객체 표현</h2><hr><p>Babel 은 JSX 를 React.createElement() 호출로 컴파일합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsx</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"greeting"</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">"h1"</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">"greeting"</span> &#125;,</span><br><span class="line">  <span class="string">"Hello, world!"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>React.createElement() 는 버그 없는 코드를 작성하는 데<br>도움을 주는 몇 가지 체크를 하긴 하지만,<br>기본적으로는 아래와 같은 객체를 생성합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: this structure is simplified</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">"h1"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">"greeting"</span>,</span><br><span class="line">    children: <span class="string">"Hello, world"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이 객체를 “React 요소”라고 부릅니다.<br>화면에서 보고자 하는 내용에 대한 설명 내지 서술로 생각할 수 있습니다.<br>React 는 이 객체를 읽어들이고 이를 사용하여<br>DOM 을 만들어낸 뒤 최신 상태로 유지합니다.<br><br></p><p>팁 : ES6 및 JSX 코드가 모두 올바르게 표시되도록<br>선택한 편집기에 “Babel” 언어 설정 을 사용하는 것이 좋습니다.<br></p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;JSX 란?&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;JSX 는 자바스크립트의 확장문법으로 JSX 를 리액트와 함께 사용하면&lt;br&gt;
UI 가 실제로 어떻게 보일지 서술할 수 있습니다.&lt;br&gt;
JSX 는 템플릿 언어처럼 보일 수 있지만 템플릿 언어는 아닙니다.&lt;b
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="JSX" scheme="https://leekeunhwan.github.io/tags/JSX/"/>
    
  </entry>
  
  <entry>
    <title>React 16의 특징</title>
    <link href="https://leekeunhwan.github.io/2018/06/12/React16/"/>
    <id>https://leekeunhwan.github.io/2018/06/12/React16/</id>
    <published>2018-06-12T09:18:30.000Z</published>
    <updated>2018-08-01T04:41:57.972Z</updated>
    
    <content type="html"><![CDATA[<h2>How To Change Multiple JSX Elements Return</h2><p>기존에는 JSX Elements 를 Render 함에 있어서<br>한개의 JSX Elements 만 가능해서 div, span 태그로 감싸서<br>렌더링을 하곤 하였습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이렇게 말이죠</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;h1&gt;hello world&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 React 16 에서는 React.Fragment 를 지원합니다.<br>span 이나 div 로 감싸게 되는 경우에는 CSS 를 할 때<br>꼬이거나 뭔가 문제가 생길 가능성이 있는데<br>React.Fragment 태그를 사용하게 되면 기존 span 과 div 로<br>감쌀때처럼 잘 출력이 되면서도 문제가 생길 가능성이 많이 줄어들어<br>좋은 기능이라고 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;header /&gt;</span><br><span class="line">        &lt;div /&gt;</span><br><span class="line">        &lt;footer /&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br><br><h2>Strings are returned.</h2><p>기존의 React 에서는 오직 return 할 수 있는 것이<br><code>Component</code> 아니면 <code>Null</code> 이였습니다.<br>하지만 React 16 부터는 아래처럼 string 을 return 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringReturn</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;StringReturn /&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ hello</span></span><br></pre></td></tr></table></figure><br><br><h2>portals</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>portals 는 React root 밖에서 렌더를 할 때 사용할 수 있는 기능입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>What is Portals?<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPortal &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Portals</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> createPortal(<span class="xml"><span class="tag">&lt;<span class="name">Message</span> /&gt;</span>, documents.getElementById("here"));</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const Message = () =&gt; "This is Portals";</span></span><br></pre></td></tr></table></figure><p>portals 는 html 을 변경하지 못할 때 유용하게 사용될 수 있습니다.</p><br><br><h2>Error Boundaries</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorMaker</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    friends: [<span class="string">"jisu"</span>, <span class="string">"flynn"</span>, <span class="string">"daal"</span>, <span class="string">"kneeprayer"</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        friends: <span class="literal">undefined</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; friends &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> friends.map(<span class="function"><span class="params">friend</span> =&gt;</span> <span class="string">` <span class="subst">$&#123;friend&#125;</span> `</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ErrorFallback = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">" Sorry something went wrong"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    hasError: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidCatch = <span class="function">(<span class="params">error, info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      hasError: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &#123;hasError ? <span class="xml"><span class="tag">&lt;<span class="name">ErrorFallback</span> /&gt;</span> : <span class="tag">&lt;<span class="name">ErrorMaker</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">    );</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>기존에는 에러가 발생하면 리액트 앱이 죽어버렸는데<br>React16 에서는 componentDidCatch 를 통해<br>컴포넌트가 에러를 캐치하면 기존에 정상적으로 작동하는 것들은 살려두고<br>에러에만 대응하는 모습을 볼 수 있습니다.</p><br><br><h2>Error Boundaries with Higher Order Components</h2><p>컴포넌트에서 에러를 잡는 것은 굉장히 매력적인 일이지만<br>JSX 엘리먼트가 많다면 에러를 잡기 위해 그 많은 코드에다가<br>일일히 삼항연산자로 에러를 잡는 코드를 만드는 것은 굉장히 비효율적입니다.<br>그래서 있는 것이 <code>HOC(고차 컴포넌트)</code> 입니다.</p><p>개발단에서만 에러가 발생시 보이므로 사용자 경험을 좋도록 할 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createPortal &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundaryHOC = <span class="function"><span class="params">ProtectedComponent</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Boundary</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">      hasError: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    componentDidCatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        hasError: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; hasError &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">      <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ErrorFallback</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">      &#125; else &#123;</span></span><br><span class="line"><span class="xml">        return <span class="tag">&lt;<span class="name">ProtectedComponent</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class ErrorMaker extends Component &#123;</span></span><br><span class="line"><span class="xml">  state = &#123;</span></span><br><span class="line"><span class="xml">    friends: ["jisu", "flynn", "daal", "kneeprayer"]</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">  componentDidMount = () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="xml">      this.setState(&#123;</span></span><br><span class="line"><span class="xml">        friends: undefined</span></span><br><span class="line"><span class="xml">      &#125;);</span></span><br><span class="line"><span class="xml">    &#125;, 2000);</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    const &#123; friends &#125; = this.state;</span></span><br><span class="line"><span class="xml">    return friends.map(friend =&gt; ` $&#123;friend&#125; `);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const PErrorMaker = BoundaryHOC(ErrorMaker);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class Portals extends Component &#123;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return createPortal(<span class="tag">&lt;<span class="name">Message</span> /&gt;</span>, document.getElementById("touchme"));</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const PPortals = BoundaryHOC(Portals);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const Message = () =&gt; "Just touched it!";</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class ReturnTypes extends Component &#123;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return "hello";</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const ErrorFallback = () =&gt; "Sorry something went wrong";</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class App extends Component &#123;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;ReturnTypes /&gt;</span><br><span class="line">        &lt;PPortals /&gt;</span><br><span class="line">        &lt;PErrorMaker /&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">    );</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default BoundaryHOC(App);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;How To Change Multiple JSX Elements Return&lt;/h2&gt;
&lt;p&gt;기존에는 JSX Elements 를 Render 함에 있어서&lt;br&gt;
한개의 JSX Elements 만 가능해서 div, span 태그로 감싸서&lt;br&gt;
렌
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="React16" scheme="https://leekeunhwan.github.io/tags/React16/"/>
    
  </entry>
  
</feed>
