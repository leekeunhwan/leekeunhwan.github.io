<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moong2&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leekeunhwan.github.io/"/>
  <updated>2018-08-01T07:05:52.942Z</updated>
  <id>https://leekeunhwan.github.io/</id>
  
  <author>
    <name>Moong2</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>List_&amp;_Key (리스트와 키)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/List-Key/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/List-Key/</id>
    <published>2018-08-01T06:17:52.000Z</published>
    <updated>2018-08-01T07:05:52.942Z</updated>
    
    <content type="html"><![CDATA[<h2>리스트와 키</h2><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> number * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(doubled);</span><br></pre></td></tr></table></figure><p>위의 코드는 map 메소드를 사용하여 numbers 의 각 항목을 2 배로 만들었습니다.<br>React 에서도 비슷한 과정을 통해 요소 목록을 배열로부터 계산해낼 수 있습니다.</p><br><h2>컴포넌트 여러 개를 렌더링하기</h2><p>요소 목록을 만든 뒤에는 중괄호 {} 를 사용하여<br>JSX 에 포함 시키는 것이 가능합니다.</p><p>아래 예제에서는 자바스크립트의 map() 함수를 사용해서<br>numbers 배열을 순회하면서, 각 항목에 대해 <code>&lt;li&gt;</code> 요소를 반환합니다.<br>마지막으로, 결과적으로 얻어낸 요소 배열을 listItems 에 대입합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> &lt;li&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;);</span></span><br></pre></td></tr></table></figure><p>전체 listItems 배열을 <code>&lt;ul&gt;</code> 요소 안에 삽입해서 DOM 에 렌더링 해줄 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>이 코드는 1 부터 5 까지의 숫자로 이루어진 목록을 표시합니다.</p><br><h2>기본적인 목록 컴포넌트</h2><hr><p>여러분은 대개 컴포넌트 안에서 목록을 렌더링하게 됩니다.<br>이전 예제를 리팩토링해서, numbers 배열을 받아<br>ul 을 출력하는 컴포넌트를 만들어봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> &lt;li&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;);</span></span><br><span class="line"><span class="regexp">  return &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이 코드를 실행하면, 목록의 각 항목에 키를 넣어야한다는 경고가 표시됩니다.<br><code>“키(key)“</code>는 <code>요소 목록를 만들 때 포함해야하는 특수한 문자열 속성</code>입니다.<br>다음 섹션에서 키의 중요성에 대해 더 살펴봅니다.</p><p>numbers.map() 안에서 각 항목에 key 를 할당하여 키 관련 경고를 해결해봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">    &lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  ));</span></span><br><span class="line"><span class="regexp">  return &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 메소드에서 반환하는 요소에는 key prop을 꼭 넣어줘야 합니다.</span></span><br><span class="line"><span class="comment">// key prop에서 다만 index를 사용해서는 안됩니다. (사용하나 마나입니다. / index가 바뀌지 않으면서 안정된 식별자가 필요할 경우 index를 넘겨주기도 합니다.)</span></span><br><span class="line"><span class="comment">// key를 주게되면 React는 정확히 어느 요소를 변경해야할지 알게되므로 의도한 대로 작동합니다.</span></span><br><span class="line"><span class="comment">// 하지만 key를 안주면 React는 정확히 어느 요소를 변경해야할지 모르므르 배열의 마지막 요소를 삭제합니다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    numbers: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> numbers = <span class="keyword">this</span>.state.numbers;</span><br><span class="line">    <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number, index</span>) =&gt;</span> (</span><br><span class="line">      &lt;div key=&#123;number&#125;&gt;</span><br><span class="line">        &lt;span&gt;&#123;number&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="text" /</span>&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;e =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">              numbers: numbers.filter(<span class="function">(<span class="params">item, i</span>) =&gt;</span> i !== index)</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          삭제</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><br><h2>키</h2><hr><p><code>키를 지정해주면 어떤 아이템이 바뀌었는지, 추가되었는지,</code><br><code>삭제되었는 지를 React 에게 알려줄 수 있습니다.</code><br>(안알려주면 의도치않게 동작합니다.)<br></p><p>배열에 들어있는 요소마다 식별자를 키로 넣어주세요.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">  &lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br></pre></td></tr></table></figure><p>키로 쓰기에 가장 적절한 값은 각 항목을<br>고유하게 식별할 수 있는 문자열입니다.<br>대부분의 경우 데이터의 ID 를 키로 사용합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.text&#125;&lt;<span class="regexp">/li&gt;);</span></span><br></pre></td></tr></table></figure><p>만약 그러한 값이 없다면, 최후의 수단으로 배열 인덱스를 키로 사용할 수도 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> (</span><br><span class="line">  <span class="comment">// Only do this if items have no stable IDs</span></span><br><span class="line">  &lt;li key=&#123;index&#125;&gt;&#123;todo.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br></pre></td></tr></table></figure><p>항목 간 순서가 바뀔 수 있는 경우 키에 인덱스를 사용하지 않는 게 좋습니다.<br>이로 인해 성능이 저하되거나 컴포넌트의 state 와 관련된 문제가 생길 수 있습니다.</p><p>Robin Pokorny 가 작성한 아티클인<br>[인덱스를 키로 사용할 때의 부정적인 영향에 대한 심층적 설명]<br>(in-depth explanation on the negative impacts of using an index as a key)를<br>참고하시길 바랍니다.</p><p>[<a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" target="_blank" rel="noopener">https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318</a>]</p><p>만약 <code>명시적으로 키를 지정하지 않으면</code><br><code>React 는 기본적으로 인덱스를 키로 사용</code>합니다.<br></p><br><h2>키로 컴포넌트 추출하기</h2><hr><p><code>키는 바로 바깥쪽의 배열에 대해서만 의미</code>를 가집니다.</p><p>예를 들어, ListItem 컴포넌트를 추출 한 경우,<br>ListItem 자체의 루트 <code>&lt;li&gt;</code> 요소가 아닌<br>배열의 <code>&lt;ListItem /&gt;</code> 요소가 키를 가지고 있어야합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 잘못된 키 사용법의 예</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = props.value;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 틀렸습니다! 여기서 키를 넣어주는 것은 아무런 효과가 없습니다.</span></span><br><span class="line">    &lt;li key=&#123;value.toString()&#125;&gt;&#123;value&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function NumberList(props) &#123;</span></span><br><span class="line"><span class="regexp">  const numbers = props.numbers;</span></span><br><span class="line"><span class="regexp">  const listItems = numbers.map(number =&gt; (</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 틀렸습니다! 바로 여기서 키를 넣어주어야 합니다.</span></span><br><span class="line"><span class="regexp">    &lt;ListItem value=&#123;number&#125; /</span>&gt;</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 올바른 키 사용법의 예</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 맞았습니다! 여기서 키를 넣어주는 것이 아닙니다.</span></span><br><span class="line">  <span class="keyword">return</span> &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">    <span class="comment">// 맞았습니다! 바로 여기서 키를 넣어주어야 합니다.</span></span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>”map() 에서 반환하는 요소에는 키를 넣어준다”</code>고 외워두어도 좋습니다.</p><br><h2>키는 형제 중에서 고유한 값이어야한다.</h2><hr><p><code>배열 내에서 사용되는 키는 형제 간에 고유해야합니다.</code><br>그러나 <code>전체 범위에서 고유할 필요는 없습니다.</code><br>서로 다른 두 배열을 생성할 때는 동일한 키를 사용할 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Blog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sidebar = (</span><br><span class="line">    &lt;ul&gt;&#123;props.posts.map(<span class="function"><span class="params">post</span> =&gt;</span> &lt;li key=&#123;post.id&#125;&gt;&#123;post.title&#125;&lt;<span class="regexp">/li&gt;)&#125;&lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> content = props.posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">    &lt;div key=&#123;post.id&#125;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;post.title&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;post.content&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ));</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;sidebar&#125;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">      &#123;content&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const posts = [</span></span><br><span class="line"><span class="regexp">  &#123; id: 1, title: "Hello World", content: "Welcome to learning React!" &#125;,</span></span><br><span class="line"><span class="regexp">  &#123; id: 2, title: "Installation", content: "You can install React from npm." &#125;</span></span><br><span class="line"><span class="regexp">];</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Blog posts=&#123;posts&#125; /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p><code>키는 React 에게 힌트를 제공하지만 컴포넌트로 전달되지는 않습니다.</code><br>(역주: 컴포넌트 안에서 this.props.key 와 같이 가져와서 쓰는 것이 불가능)</p><p>만약 <code>컴포넌트에 동일한 값이 필요하다면</code><br><code>명시적으로 다른 이름의 prop 으로 전달</code>하도록 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> content = posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">  &lt;Post key=&#123;post.id&#125; id=&#123;post.id&#125; title=&#123;post.title&#125; /&gt;</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>위 예제에서 Post 컴포넌트는 <a href="http://props.id" target="_blank" rel="noopener">props.id</a> 를 읽을 수 있지만,<br>props.key 는 읽을 수 없습니다.</p><br><br><h2>JSX 에서 map() 포함하기</h2><p>위 예제에서 별도의 listItems 변수를 선언하고 이를 JSX 에 포함시켰습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSX 는 중괄호 안에 임의의 표현식을 포함 할 수 있기 때문에,<br>map() 도 인라인으로 포함시킬 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">        &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>위 스타일을 통해 코드가 더 명확해질 수도 있지만 남용하는 것은 좋지 않습니다.</p><p>자바스크립트와 마찬가지로, 가독성을 위해 변수로 추출해야할지<br>아니면 인라인으로 넣을지는 개발자가 직접 판단해야합니다.</p><p><code>map() 함수가 너무 중첩되어있다면, 컴포넌트로 추출 하는 것이 좋습니다.</code></p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;리스트와 키&lt;/h2&gt;
&lt;hr&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
      <category term="Key" scheme="https://leekeunhwan.github.io/tags/Key/"/>
    
      <category term="List" scheme="https://leekeunhwan.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>Conditional_Render (조건부 렌더링)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/Conditional-Render/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/Conditional-Render/</id>
    <published>2018-08-01T04:34:44.000Z</published>
    <updated>2018-08-01T06:17:25.878Z</updated>
    
    <content type="html"><![CDATA[<h2>조건부 렌더링</h2><hr><p>React 에서는, <code>컴포넌트를 만들어서 원하는 동작을 캡슐화</code>할 수 있습니다.<br>그리고 나서, <code>어플리케이션의 상태에 따라 컴포넌트의 일부만 렌더링</code>할 수 있습니다.</p><p>React 의 <code>조건부 렌더링은 자바스크립트의 조건문과 동일한 방식으로 동작</code>합니다.<br>if 나 조건 연산자 같은 자바스크립트 연산자를 사용하여<br>현재 상태를 표현하는 요소를 만들고, 요소에 맞게 UI 를 갱신하세요.</p><p>두 컴포넌트를 살펴봅시다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Welcome back!&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Please sign up.&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자의 로그인 여부에 따라 다음 컴포넌트 중<br>하나를 표시하는 Greeting 컴포넌트를 만들었습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;UserGreeting /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;GuestGreeting /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  // Try changing to isLoggedIn=&#123;true&#125;:</span><br><span class="line">  &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;,</span><br><span class="line">  document.getElementById("root")</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이 예제는 isLoggedIn 의 prop 값에 따라 다른 메시지를 노출시킵니다.</p><br><h2>요소 변수</h2><hr><p><code>요소를 담기 위해 변수를 사용</code>할 수 있습니다.<br>이렇게 하면 다른 부분을 바꾸지 않으면서도<br><code>컴포넌트의 일부를 조건부로 렌더링하기가 쉬워집니다.</code></p><p>로그아웃과 로그인 버튼을 나타내는 두 개의 새 컴포넌트를 살펴봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;props.onClick&#125;&gt;Login&lt;/button&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LogoutButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;props.onClick&#125;&gt;Logout&lt;/button&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서, LoginControl 이라는 stateful 컴포넌트 를 생성했습니다.<br>이 컴포넌트는 현재 상태에 따라 <code>&lt;LoginButton /&gt;</code> 혹은<br><code>&lt;LogoutButton /&gt;</code> 중 하나를 렌더링 할 것입니다.</p><p>이전 예제에서 만들었던 <code>&lt;Greeting /&gt;</code> 도 렌더링합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginControl</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleLoginClick = <span class="keyword">this</span>.handleLoginClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleLogoutClick = <span class="keyword">this</span>.handleLogoutClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isLoggedIn</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLoginClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isLoggedIn</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLogoutClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isLoggedIn</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> button = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 로그인의 변수의 값이 true면</span></span><br><span class="line">    <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">      <span class="comment">// 이거 실행</span></span><br><span class="line">      button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 거짓이면 이거 실행</span><br><span class="line">      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class="line">        &#123;button&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;LoginControl /&gt;, document.getElementById("root"));</span><br></pre></td></tr></table></figure><p>변수를 선언하고 if 문을 사용하는 것은<br>조건부로 컴포넌트를 렌더링하는 훌륭한 방법이지만,<br>원한다면 더 짧은 문법을 사용할 수도 있습니다.</p><p>JSX 에 조건을 인라인으로 넣는 몇가지 방법을 소개합니다.<br></p><br><h2>&amp;&amp; 논리 연산자를 사용해 if 를 인라인으로 넣기</h2><hr><p>중괄호로 감싸면 JSX 에 어떤 표현식이건 넣을 수 있습니다.<br>여기에는 자바스크립트 &amp;&amp; 논리 연산자도 포함됩니다.</p><p>이를 사용하면 요소를 조건부로 포함시키는 작업을 더 편하게 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      &#123;unreadMessages.length &gt; <span class="number">0</span> &amp;&amp; (</span><br><span class="line">        &lt;h2&gt;You have &#123;unreadMessages.length&#125; unread messages.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = [<span class="string">"React"</span>, <span class="string">"Re: React"</span>, <span class="string">"Re:Re: React"</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이 코드는 잘 동작하는데, 자바스크립트에서 true &amp;&amp; expression 은<br>항상 expression 으로 평가되고, false &amp;&amp; expression 은<br>항상 false 로 평가되기 때문입니다.</p><p>따라서 조건이 true 라면 &amp;&amp; 다음에 오는 요소가 노출됩니다.<br>만약 조건이 false 라면, React 는 이를 무시하고 건너뜁니다.</p><br><h2>조건부 연산자를 사용해 if-else 인라인으로 넣기</h2><hr><p>인라인으로 요소를 조건부 렌더링하는 다른 방법은<br>자바스크립트의 조건부 연산자인<br><code>condition ? true : false</code> 를사용하는 것입니다.</p><p>아래 예제에서, 작은 텍스트 블록을 조건부로 렌더링합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      The user is &lt;b&gt;&#123;isLoggedIn ? <span class="string">'currently'</span> : <span class="string">'not'</span>&#125;&lt;<span class="regexp">/b&gt; logged in.</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>좀 지저분하긴 하지만, 어쨌든 큰 표현식에서도 사용할 수는 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLoggedIn ? (</span><br><span class="line">        &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br><br><h2>컴포넌트가 렌더링 되지 못하도록 방지</h2><hr><p>흔하지 않지만 어떤 컴포넌트에 의해 렌더링된<br>컴포넌트를 숨기고 싶은 경우가 있습니다.<br>이렇게 하려면 요소 대신 null 을 반환하면 됩니다.</p><p>아래 예제에서, <code>&lt;WarningBanner /&gt;</code> 는<br>warn prop 의 값에 의존해 렌더링됩니다.<br>만약 prop 값이 false 라면, 이 컴포넌트는 렌더링되지 않습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div className="warning"&gt;Warning!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">showWarning</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleToggleClick = <span class="keyword">this</span>.handleToggleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      showWarning: !prevState.showWarning</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;WarningBanner warn=&#123;<span class="keyword">this</span>.state.showWarning&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.showWarning ? <span class="string">"Hide"</span> : <span class="string">"Show"</span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Page /&gt;, document.getElementById("root"));</span><br></pre></td></tr></table></figure><p>컴포넌트의 render 메서드에서 null 을 반환한다고 해서,<br>컴포넌트의 라이프사이클 메서드 호출 과정에 영향을 미치지는 않습니다.</p><p>예를 들어, componentWillUpdate 와<br>componentDidUpdate 가 여전히 호출됩니다.<br></p><p><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;조건부 렌더링&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;React 에서는, &lt;code&gt;컴포넌트를 만들어서 원하는 동작을 캡슐화&lt;/code&gt;할 수 있습니다.&lt;br&gt;
그리고 나서, &lt;code&gt;어플리케이션의 상태에 따라 컴포넌트의 일부만 렌더링&lt;/code&gt;할 수 있습
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="Conditional Render" scheme="https://leekeunhwan.github.io/tags/Conditional-Render/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Event_Handling (이벤트 제어하기)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/Event-Handling/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/Event-Handling/</id>
    <published>2018-08-01T03:56:07.000Z</published>
    <updated>2018-08-01T04:43:08.219Z</updated>
    
    <content type="html"><![CDATA[<h2>이벤트 제어하기</h2><hr><p>React 요소의 이벤트를 제어하는 것은<br>DOM 요소 이벤트를 제어하는 것과 매우 유사합니다.</p><p>다만 몇가지 문법적인 차이가 있습니다.</p><ul><li><code>React 이벤트</code>는 소문자 대신 <code>camelCase 를 사용</code>합니다.</li><li><code>JSX 에</code> 문자열 대신 <code>함수를 전달</code>합니다.</li></ul><br><p>예를 들어 HTML 에서 이벤트를 넣을 때는 이렇게 합니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"activateLasers()"</span>&gt;Activate Lasers&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>React 에서는 조금 다릅니다</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;Activate Lasers&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>다른 차이점으로는 React 에서 기본 동작을 막기 위해<br>false 를 반환할 수 없다는 것입니다.</p><p>반드시 명시적으로 <code>preventDefault()</code> 를 호출해야 합니다.<br>예를 들어 HTML 에서 새로운 페이지를 여는 기본 링크 동작을 막으려면<br>아래와 같이 작성할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#"</span> onclick=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span><br><span class="line">  Click me</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>React 에서는 대신 이렇게 작성합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The link was clicked."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>여기서 e 는 합성 이벤트입니다.<br>React 는 W3C spec 에 따라 이런 합성 이벤트를 정의하므로,<br>브라우저 간 호환성을 걱정할 필요는 없습니다.<br>더 자세한 사항은 <a href="https://reactjs.org/docs/events.html" style="color:salmon;" target="_blank" rel="noopener">SyntheticEvent 레퍼런스 가이드</a>를 보시길 바랍니다.</p><p>React 를 사용할 때, (일반적인 경우) 리스너를 추가하기 위해<br>DOM 요소가 생성된 후 addEventListener 를 호출할 필요가 없습니다.<br>대신 요소를 처음 렌더링할 때 리스너를 같이 넘겨주세요.</p><p>ES6 class 를 이용해 컴포넌트를 정의할 때,<br><code>이벤트 핸들러를 만들기 위해 보통 클래스 메서드를 사용</code>합니다.</p><p>예를 들어, 아래 Toggle 컴포넌트는 “ON” 과 “OFF” state 를<br>유저가 토글할 수 있게 하는 버튼을 렌더링합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 다른 곳에 넘겨주는 함수는 가급적 화살표함수로 만들어서 사용하는 것이 좋습니다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isToggleOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 콜백에서 `this`가 제대로 동작하게 만들려면 아래 바인딩을 꼭 해주어야 합니다.</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="string">"ON"</span> : <span class="string">"OFF"</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Toggle /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>JSX 콜백에서 this 의 의미에 대해 주의해야합니다.<br><code>자바스크립트에서 클래스 메서드는 기본적으로 바인딩 되지 않습니다.</code><br>만약 this.handleClick 바인드를 잊은채로 onClick 에 전달하면,<br>this 는 함수가 실제로 호출될 때 undefined 로 취급됩니다.</p><p>이건 React 에서만 해당되는 동작이 아닙니다.<br>자바스크립트의 함수의 동작 방식 자체가 이렇습니다.<br>일반적으로 onClick={this.handleClick} 처럼 () 없이 메서드를 참조하면,<br>그 <code>메서드를 bind 해야합니다.</code></p><p>만약 bind 를 호출하는 게 귀찮은 경우,<br>이 문제를 해결할 수 있는 두 가지 방법이 있습니다.</p><p>만약 실험적 기능인 <code>퍼블릭 클래스 필드 문법 을 사용하고 있다면,</code><br>콜백을 올바르게 바인딩하기 위해 <code>클래스 필드를 사용할 수 있습니다.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 이 문법은 handleClick 안에서 `this`가 제대로 바인딩됨을 보장합니다.</span></span><br><span class="line">  <span class="comment">// 경고: 이는 *실험적인* 문법입니다.</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"this is:"</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Create React App 을 사용하고 있다면<br>이 문법을 바로 사용할 수 있습니다.</p><p>만약 <code>클래스 필드 문법을 사용하고 싶지 않다면,</code><br><code>콜백에서 arrow function 을 사용</code>할 수도 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"this is:"</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// This syntax ensures `this` is bound within handleClick</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.handleClick(e)&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 문법의 문제점은 LogginButton 을 렌더링할 때마다<br>서로 다른 콜백이 만들어지는 것입니다.</p><p>대부분의 경우에서 크게 문제는 없습니다.</p><p>하지만 <code>하위 컴포넌트에 콜백을 prop 으로서 전달하는 경우,</code><br>이 컴포넌트는 <code>불필요한 렌더링을 더 일으킬 수 있습니다.</code></p><p>이런 종류의 성능 문제를 피하기 위해,<br><code>보통 생섬자 함수에서 바인딩하거나 클래스 필드 문법을 사용하는 걸 권장</code>합니다.</p><br><h2>이벤트 핸들러에 인수 전달하기</h2><hr><p>반복문 안에서 이벤트 핸들러에 추가 파라미터를 전달하고 싶은 경우가 많습니다.<br>예를 들어, 만약 id 가 행 ID 라면, 아래처럼 전달할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure><p>위 두 라인은 동일하며,<br><code>arrow functions</code> 과 <code>Function.prototype.bind</code> 를 각각 사용하고 있습니다.</p><p>두 경우 모두, React 이벤트를 나타내는 e 인수는<br>ID 뒤에 두 번째 인수로 전달됩니다.</p><p><code>arrow function 을 사용하면 ID 를 명시적으로 전달</code>해야 하지만,<br><code>bind 를 사용하면 추가로 넘겨준 인수가 자동으로 전달</code>됩니다.</p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;이벤트 제어하기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;React 요소의 이벤트를 제어하는 것은&lt;br&gt;
DOM 요소 이벤트를 제어하는 것과 매우 유사합니다.&lt;/p&gt;
&lt;p&gt;다만 몇가지 문법적인 차이가 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;React 이벤트
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="Event" scheme="https://leekeunhwan.github.io/tags/Event/"/>
    
      <category term="Event Handling" scheme="https://leekeunhwan.github.io/tags/Event-Handling/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>State_&amp;_Life_Cycle (상태와 라이프사이클)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/State-Life-Cycle/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/State-Life-Cycle/</id>
    <published>2018-08-01T03:31:34.000Z</published>
    <updated>2018-08-01T04:44:14.262Z</updated>
    
    <content type="html"><![CDATA[<h2>State 와 라이프사이클</h2><hr><p>지금까지 우리는 UI 를 업데이트하는 한가지 방법을 배웠습니다.<br>ReactDOM.render() 을 호출하여 렌더링된 출력을 변경합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>이 섹션에서는 재사용가능하고 캡슐화된<br>Clock 컴포넌트를 만드는 방법에 대해 배웁니다.<br>자체 타이머를 설정하고 매 초마다 스스로 업데이트합니다.<br></p><p>시계가 어떻게 보이는 지 캡슐화하는 것부터 시작합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> <span class="attr">date</span>=<span class="string">&#123;new</span> <span class="attr">Date</span>()&#125; /&gt;</span>, document.getElementById("root"));</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">setInterval(tick, 1000);</span></span><br></pre></td></tr></table></figure><p>그러나 중요한 요구사항이 하나 빠져있습니다.<br>Clock 이 타이머를 설정하고 매 초 UI 를 업데이트 하는 것은<br>Clock 의 구현 세부사항이어야 합니다.<br></p><p>이상적으로 Clock 은 한번만 작성하고 자체적으로 업데이트 시키려고 합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>이걸 구현하기 위해, Clock 컴포넌트에 <code>“state”</code>를 추가할 필요가 있습니다.<br>State 는 props 와 비슷하지만 <code>컴포넌트에 의해 완전히 제어되며 private 속성</code>입니다.<br>이전에 언급 했던 대로 클래스로 정의한 컴포넌트에는 몇가지 추가 기능이 있습니다.<br>로컬 state 는 클래스에서만 사용 가능한 기능입니다.</p><br><h2>함수를 클래스로 변환</h2><hr><p>Clock 같은 함수형 컴포넌트를 클래스로 변환하려면 다섯 단계를 진행합니다.</p><ol><li>ES6 class 를 같은 이름으로 만들고, React.Component 를 확장합니다.</li><li>비어있는 render() 메서드를 하나 추가합니다.</li><li>함수의 바디를 render() 메서드 안으로 옮깁니다.</li><li>render() 바디 내에서 props 를 this.props 로 바꿉니다.</li><li>남아있는 빈 함수 선언문을 제거합니다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clock 은 이제 함수 대신 클래스로 정의합니다.<br>이를 통해 로컬 state 나 라이프사이클 훅 같은 추가 기능을 사용할 수 있습니다.</p><br><h2>Class 에 로컬 state 추가하기</h2><hr><p>date 를 props 에서 state 로 옮기기 위해서 세 단계를 진행합니다.</p><ol><li>render() 메서드 내의 this.props.date 를 this.state.date 로 바꿉니다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ol start="2"><li>this.state 를 초기화 하는 클래스 생성자 를 추가합니다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>props 를 기본 생성자에 어떻게 전달하는 지 살펴보길 바랍니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">   <span class="keyword">super</span>(props);</span><br><span class="line">   <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>클래스 컴포넌트는 항상 props 와 함께 기본 생성자를 호출합니다.<br></p><ol start="3"><li><clock> 요소에서 date prop 을 삭제합니다.</clock></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>나중에 타이머 코드를 컴포넌트 자체에 다시 추가합니다.<br>이 결과는 다음과 같은 코드가 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>다음으로, Clock 에 자체 타이머를 설정하고<br>매 초마다 자체적으로 업데이트 하는 걸 만들어봅시다.</p><br><h2>클래스에 라이프사이클 메서드 추가하기</h2><hr><p>많은 컴포넌트를 가진 어플리케이션에서,<br>컴포넌트가 제거될 때 리소스를 풀어주는 건 아주 중요한 일입니다.<br>Clock 이 DOM 에 최초로 렌더링 될 때 타이머를 설정 하려고 합니다.<br>React 에서 이를 <code>mounting</code> 이라고 부릅니다.</p><p>그리고 DOM 에서 Clock 을 삭제했을 때 타이머를 해제 하려고 합니다.<br>React 에서 이를 <code>unmounting</code> 이라고 부릅니다.<br><br>컴포넌트가 마운트 (mount) 되고 언마운트 (unmount) 될 때<br>특정 코드를 실행하기 위해 컴포넌트 클래스에 특별한 메서드를 선언할 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Life Cycle</span></span><br><span class="line"><span class="comment">// Render: componentWillMount() -&gt; render() -&gt; componentDidMount()</span></span><br><span class="line"><span class="comment">// Update componentWillReceiveProps() -&gt; shouldComponentUpdate() -&gt; componentWillUpdate() -&gt; render() -&gt; componentDidUpdate()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 메서드들을 “라이프사이클 훅” 이라고 부릅니다.<br><code>componentDidMount()</code> 훅은 컴포넌트 출력이 DOM 에 렌더링 된 이후 동작합니다.<br>이 부분이 타이머를 설정하기 좋은 지점입니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">    () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this 에 timer ID 를 어떻게 저장하는 지 살펴봅시다.<br></p><p>렌더링과 관련된 데이터 흐름에서, this.props 는 React 에 의해 설정되고<br>this.state 는 특별한 의미를 갖고 있습니다.</p><p>반면 위와 같이 데이터 흐름에 참여하지 않는 무언가를 저장할 때<br>클래스에 직접 필드를 추가하는 것도 가능합니다.</p><p>이제 <code>componentWillUnmount()</code> 라이프사이클 훅에서 타이머를 종료할 것입니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 Clock 컴포넌트에서<br>매 초마다 동작하는 tick() 이라는 메서드를 구현해봅시다.<br></p><p><code>this.setState()</code> 를 사용해서 컴포넌트 로컬 state 에 대한 업데이트를 예약합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 리액트는 최초 렌더를 제외하고는 변화가 있어야 화면을 렌더합니다.</span></span><br><span class="line"><span class="comment">// componentDidMount는 1초마다 tick을 호출하고,</span></span><br><span class="line"><span class="comment">// tick은 state를 변경해줍니다.</span></span><br><span class="line"><span class="comment">// state가 변경되었기에 다시 렌더가 되고,</span></span><br><span class="line"><span class="comment">// 렌더가 완료된 후에 clearInterval이 이루어집니다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 클래스 필드를 사용하면 생성자를 사용하지 않고도 초기 값을 지정할 수 있다.</span></span><br><span class="line">  <span class="comment">// state = &#123; date: new Date() &#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.tick(), <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// tick을 1초에 한번씩 호출하면 setState를 호출하니 화면을 다시 그려주게 되는 셈입니다.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      <span class="comment">//  1. 상태를 바꿔주고, 2. 화면이 간접적으로 다시 그려지도록 해줍니다.</span></span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 상태로 부터 화면이 어떻게 그려져야 하는지를 render 메소드에 서술합니다.</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>이제 시계는 매 초 깜빡입니다.<br>어떤 작업을 했는 지와 메서드가 호출되는 순서를 간단히 요약해봅시다.</p><p><code>&lt;Clock /&gt;</code> 이 <code>ReactDOM.render() 에 전달</code>될 때,<br><code>React 는 Clock 컴포넌트의 생성자 함수를 호출</code>합니다.</p><p>Clock 이 현재 시각을 화면에 보여주어야 하기 때문에,<br>현재 시각을 포함하는 <code>this.state 객체를 초기화</code>합니다.<br>이 <code>state 는 추후 업데이트</code>됩니다.</p><p>React 가 <code>Clock 컴포넌트의 render() 메서드를 호출</code>합니다.<br>이를 통해 React 는 화면에 무엇을 보여줘야 하는지 알아냅니다.<br>그 다음 React 는 <code>DOM 을 갱신해서 Clock 의 렌더링 출력과 일치</code>시킵니다.</p><p><code>Clock 출력이 DOM 에 주입되었을 때,</code><br>React 는 <code>componentDidMount() 라이프 훅을 호출</code>합니다.<br>그 안에서 <code>Clock 컴포넌트는 브라우저에게 컴포넌트의 tick() 메서드를</code><br><code>초당 한 번씩 호출하는 타이머를 설정하라고 명령</code>합니다.</p><p>브라우저에서 매 초마다 tick() 메서드를 호출합니다.<br>그 안에서 Clock 컴포넌트는 현재 시각을 갖고 있는 객체를 가지고<br><code>setState() 를 호출하여 UI 업데이트를 예약</code>합니다.</p><p><code>setState() 호출 덕분에, React 는 상태가 변경</code>된 걸 알게 됐고,<br>(setState()를 호출하면 화면이 다시그려지게 된다는 것도 기억해야 합니다.)<br>render() 메서드를 <code>다시 한 번 호출해 화면에 무엇을 표시</code>해야 할지 알 수 있습니다.<br>이번에는, render() 메서드 내의 <code>this.state.date 가 달라지므로</code><br><code>바뀐 시간이 출력에 포함</code>됩니다. React 는 그에 따라 DOM 을 업데이트합니다.</p><p>만약 <code>Clock 컴포넌트가 DOM 에서 삭제</code>된다면,<br>React 는 <code>componentWillUnmount() 라이프사이클 훅을 호출</code>하기 때문에<br><code>타이머가 멈춥니다.</code></p><br><h2>State 바르게 사용하기</h2><hr><ul><li><b style="color:salmon;">State 를 직접 수정하지 마세요</b></li></ul><p>이 코드는 컴포넌트를 다시 렌더링하지 않습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><p>대신, setState() 를 사용하세요.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">comment</span>: <span class="string">"Hello"</span> &#125;);</span><br></pre></td></tr></table></figure><p><code>this.state 를 할당할 수 있는 유일한 장소는 생성자 함수 내부</code>입니다.</p><ul><li><b style="color:salmon;">State 업데이트는 비동기일 수 있습니다</b></li></ul><p><code>React 는 성능을 위해 여러 setState() 호출을</code><br><code>한 번의 작업으로 묶어서 처리하는 경우</code>가 있습니다.</p><p><code>this.props 및 this.state 가 비동기로 업데이트될 수 있기 때문</code>에,<br>다음 <code>state 를 계산할 때 이 값을 신뢰해서는 안됩니다.</code></p><p>예를 들어, 카운터를 업데이트하는 이 코드는 실패할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이 문제를 해결하기 위해 객체가 아닌<br>함수를 받는 두 번째 형식의 setState() 를 사용할 수 있습니다.</p><p>이 함수는 이전 state 를 첫 번째 인수로 받고,<br>두 번째 인수로 업데이트가 적용 될 때 props 를 받습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이전 상태로부터 새 상태를 계산할 때는 콜백 형식의 setState를 사용해야 합니다.</span></span><br><span class="line"><span class="comment">// 객체를 바로 반환받음에도 중괄호를 괄호로 덮어줘야 합니다. 안그러면 에러가 발생합니다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>위 예제에서는 arrow function 을 사용했지만, 평범한 함수도 동작합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">prevState, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><ul><li><b style="color:salmon;">State 업데이트는 병합됩니다</b></li></ul><p><code>setState() 를 호출할 때, React 는 넘겨받은 객체를 현재 state 에 병합</code>합니다.<br>예를 들어, <code>state 는 여러 독립적인 변수를 가질 수 있습니다.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    posts: [],</span><br><span class="line">    comments: []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런 다음 <code>개별 setState() 를 호출하여 아이템을 각각 업데이트할 수 있습니다.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  fetchPosts().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      posts: response.posts</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fetchComments().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      comments: response.comments</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 때 얕은 병합을 수행하기 때문에, this.setState({comments}) 는<br>this.state.posts 는 그대로 두지만, this.state.comments 는 완전히 대체합니다.</p><ul><li><b style="color:salmon;">데이터는 아래로 흐릅니다</b></li></ul><p><code>부모 컴포넌트나 자식 컴포넌트는 특정 컴포넌트의 state 유무를 알 수 없으며,</code><br><code>해당 컴포넌트가 함수나 클래스로 선언되었는 지 알 수 없습니다.</code><br>이것이 바로 state 가 ‘지역적이다’ 혹은 ‘캡슐화되었다’고 하는 이유입니다.</p><p><code>State 를 지정해 준 컴포넌트 외의 다른 컴포넌트에서는 state 에 접근할 수 없습니다.</code><br>컴포넌트는 자신의 state 를 props 로서 자식 컴포넌트에 내려줄 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br></pre></td></tr></table></figure><p>이는 사용자 정의 컴포넌트에서도 마찬가지로 동작합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedDate date=&#123;<span class="keyword">this</span>.state.date&#125; /&gt;</span><br></pre></td></tr></table></figure><p>FormattedDate 컴포넌트는 props 에서 date 를 받지만<br>이 값이 Clock 의 상태인지, Clock 의 props 인지,<br>혹은 타이핑된 것인지 알 수 없습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedDate</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 데이터 흐름을 보통 <code>“하향식(top-down)”</code> 혹은<br><code>“단방향(unidirectional)” 데이터 흐름</code>이라고 합니다.</p><p><code>모든 state 는 항상 특정 컴포넌트가 가지며,</code><br><code>해당 state 에서 파생된 모든 데이터와</code><br><code>UI 는 트리의 “아래(below)“에 있는 컴포넌트에만 영향을 미칩니다.</code></p><p>컴포넌트 트리를 props 의 폭포라고 상상해보면,<br>각 컴포넌트의 상태는 임의의 지점에서 추가되는<br>물과 비슷하고 또한 아래로 흐릅니다.</p><p>모든 컴포넌트가 실제로 격리되어있음을 보여주기 위해,<br>세 개의 <clock> 을 렌더링하는 App 컴포넌트를 만들어봅시다.</clock></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>각 Clock 은 자체적으로 타이머를 생성하고 독립적으로 바뀝니다.</p><p>React 앱에서, 컴포넌트가 state 를 갖고 있는지(stateful)<br>또는 갖지 않는지(stateless)는 구현 세부 사항으로 간주되어<br>시간이 지남에 따라 바뀔 수 있습니다.</p><p>state 를 가진 컴포넌트 내부에서 state 가 없는 컴포넌트를 사용할 수 있으며,<br>그 반대 경우도 마찬가지입니다.</p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;State 와 라이프사이클&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;지금까지 우리는 UI 를 업데이트하는 한가지 방법을 배웠습니다.&lt;br&gt;
ReactDOM.render() 을 호출하여 렌더링된 출력을 변경합니다.&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="State" scheme="https://leekeunhwan.github.io/tags/State/"/>
    
      <category term="Life Cycle" scheme="https://leekeunhwan.github.io/tags/Life-Cycle/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Component_&amp;_Props (컴포넌트와 프롭)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/Component-Props/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/Component-Props/</id>
    <published>2018-07-31T16:21:18.000Z</published>
    <updated>2018-08-01T04:42:55.436Z</updated>
    
    <content type="html"><![CDATA[<h2>컴포넌트와 props</h2><hr><p>컴포넌트를 통해 UI 를 독립적이고 재사용 가능한 부분으로 분리하고,<br>각 부분을 독립적으로 생각할 수 있습니다.<br></p><p>개념상 컴포넌트는 자바스크립트 함수와 비슷합니다.<br>“props”이라 불리는 임의의 입력을 받아들이고,<br>화면에 무엇이 표시되어야 하는지를 서술하는 React 요소를 반환합니다.</p><br><h2>함수형 및 클래스 컴포넌트</h2><hr><p>컴포넌트를 정의하는 가장 간단한 방법은 자바스크립트 함수를 작성하는 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 함수는 유효한 React 컴포넌트로,<br><code>“props”</code> (properties 를 나타냄) 객체 인수를 받고 <code>React 요소를 반환</code>합니다.<br><br>이러한 컴포넌트는 말 그대로 자바스크립트 함수이기 때문에<br><code>“함수형 컴포넌트”</code>라고 부릅니다.<br><br></p><p>컴포넌트를 정의하기 위해 ES6 class 를 사용할 수도 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 두 컴포넌트는 React 관점에서 봤을 때 동일한 기능을 갖습니다.<br></p><p>클래스는 몇가지 기능을 더 가지고 있는데, 이는 다음 섹션 에서 다룹니다.<br>그 때까지 간결함을 유지하기 위해 함수형 컴포넌트를 사용할 것입니다.<br></p><br><h2>컴포넌트 렌더링</h2><hr><p>이전에는 DOM 태그를 나타내는 React 요소만 있었습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>그러나, 는 사용자 정의 컴포넌트를 나타낼 수도 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>React 가 사용자 정의 컴포넌트를 나타내는 요소를 처리할 때는,<br><b style="color:salmon">JSX 어트리뷰트를 하나의 객체를 통해 컴포넌트로 전달</b>합니다.<br>이 객체를 <code>“props”</code> 라고 부릅니다.<br><br></p><p>예를 들어, 이 코드는 “Hello, Sara”를 페이지에 렌더링합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">ReactDOM.render(element, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><br><ol><li><p><code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> 요소로 <code>ReactDOM.render()</code> 를 호출합니다.</p></li><li><p>React 가 <code>{name: 'Sara'}</code> 를 props 로 하여 Welcome 컴포넌트를 호출합니다.</p></li><li><p>Welcome 컴포넌트가 그 결과로 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 요소를 반환합니다.</p></li><li><p>React DOM 이 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 과 일치하도록<br>DOM 을 효율적으로 업데이트합니다.<br><br></p></li></ol><p><strong style="color:salmon">[경고]</strong><br><br>컴포넌트 이름은 항상 대문자로 시작하도록 지으세요.<br>(소문자는 html 로 인식합니다.)<br><br>예를 들어 <code>&lt;div /&gt;</code> 는 DOM 태그를 나타내지만<br><code>&lt;Welcome /&gt;</code> 은 컴포넌트를 나타내며 스코프에 Welcome 이 있어야 합니다.<br></p><br><h2>컴포넌트 조립하기</h2><hr><p><strong style="color:salmon">컴포넌트의 출력에서 다른 컴포넌트를 가져와 사용할 수 있습니다.</strong><br>이를 통해 모든 세부 레벨에서 동일한 컴포넌트 추상화를 사용할 수 있습니다.<br>React 앱에서 버튼, 폼, 다이얼로그, 스크린 같은 것들은<br>모두 일반적으로 컴포넌트로 표현됩니다.<br><br></p><p>예를 들어, Welcome 을 여러번 렌더링하는 App 컴포넌트를 만들 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Sara"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Cahal"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Edite"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>일반적으로, 새롭게 작성되는 React 앱은 단일 App 컴포넌트를 최상위에 둡니다.<br>그러나 기존 앱에 React 를 도입하는 경우, Button 같은 작은 컴포넌트부터<br>덩치를 키워나가기 시작하여 점차적으로 뷰 계층의 최상단으로 나아갈 수 있습니다.</p><br><h2>컴포넌트 추출</h2><hr><p>컴포넌트를 더 작은 컴포넌트로 쪼개는 것을 두려워하지 마십시오.<br>예를 들어, Comment 컴포넌트를 살펴봅시다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;img</span><br><span class="line">          className=<span class="string">"Avatar"</span></span><br><span class="line">          src=&#123;props.author.avatarUrl&#125;</span><br><span class="line">          alt=&#123;props.author.name&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;&#123;props.author.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;&#123;props.text&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;&#123;formatDate(props.date)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>이 컴포넌트는 author (객체), text (문자열), date (Date 객체)를 props 로 받고,<br>소셜 미디어 웹사이트의 댓글을 나타냅니다.</p><p>이 컴포넌트는 중첩 때문에 변경하기 까다로울 수 있으며,<br>각 파트를 다시 사용하기도 어렵습니다.<br>여기에서 몇가지 컴포넌트를 추출해봅시다.</p><p>먼저, Avatar 를 추출할 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Avatar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;img className=<span class="string">"Avatar"</span> src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Avatar 는 자기가 Comment 내에서 렌더링되는 지를 알고 있을 필요가 없습니다.<br>따라서 author 대신 user 라는 더 일반적인 이름을 사용합니다.</p><p>속성 이름을 지을 때는,<br>컴포넌트가 사용되는 상황이 아닌 컴포넌트 그 자체만 생각하는 것이 좋습니다.<br></p><p>이제 Comment 를 약간 단순화시킬 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Avatar를 분할한 상태</span></span><br><span class="line"><span class="comment">// Comment의 기능이 많다는 것을 알 수 있습니다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;Avatar user=&#123;props.author&#125; /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;&#123;props.author.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;&#123;props.text&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;&#123;formatDate(props.date)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>이어서, 유저의 이름 옆에 Avartar 를 렌더링하는 UserInfo 컴포넌트를 추출해봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기능 분할 - userInfo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo-name"</span>&gt;&#123;props.user.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 Comment 가 더 단순해졌습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정말 Comment만 남도록 분리해서 단순해졌습니다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;&#123;props.text&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;&#123;formatDate(props.date)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>컴포넌트를 추출하는 건 처음에는 쓸데없는 일처럼 보일 수 있지만,<br>재사용 가능한 컴포넌트 팔레트를 사용하면 큰 앱에서 그 진가를 발휘합니다.</p><p>적당한 기준을 잡아보자면,<br>UI 의 일부분이 여러 번 사용되거나 (Button, Panel, Avatar),<br>자체적으로 충분히 복잡하다면 (App, FeedStory, Comment),<br>그것들은 재사용 가능한 컴포넌트가 될 좋은 후보입니다.</p><br><h2>Props 는 읽기전용입니다</h2><hr><p>컴포넌트를 함수나 클래스 중 어떤 걸로 선언했건,<br>자기 자신의 props 를 수정할 수 없습니다.<br>sum 함수를 살펴봅시다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 함수는 입력을 변경하려 하지 않고,<br><code>동일한 입력에 대해 항상 동일한 결과를 반환하기 때문에 “순수” 함수</code>라고 불립니다.</p><p>위와 반대로, 이 함수는 입력을 변경하기 때문에 순수하지 않습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">account, amount</span>) </span>&#123;</span><br><span class="line">  account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 는 매우 유연하지만 한가지 엄격한 규칙을 갖고 있습니다.<br>모든 React 컴포넌트는 props 에 대해서는 순수 함수처럼 동작해야합니다.<br></p><br><p><strong style="color:salmon">[순수 함수란?]</strong></p><p>함수는 주어진 입력으로 계산하는 것 이외에<br>프로그램의 실행에 영향을 미치지 않아야 합니다. (부수효과 X)<br>이러한 함수를 <code>순수 함수</code>라고 합니다.<br></p><p>예를 들어, count, length 함수는 임의의 문자열이나 배열에 대해서<br>항상 같은 길이를 반환하며, 그 외의 일은 일어나지 않습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func plusNumber(num: Int) -&gt; (Int -&gt; Int) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; x <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> x + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addFive = plusNumber(<span class="number">5</span>)</span><br><span class="line">addFive(<span class="number">1</span>)<span class="comment">// 5</span></span><br><span class="line">addFive(<span class="number">10</span>)<span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>위의 코드에서 익명함수를 만들어 사용하게 되고 어떤 값이 들어오던지<br>5 를 더하여 반환하게 되므로 부수 효과가 발생하지 않습니다.</p><p>순수 함수의 참조 투명성(referential transparency, RT)으로 입력 값이 같으면<br>결과 값도 같다면 표현식은 참조에 투명하다(referentially transparent)라고 합니다.<br>표현식 f(x)가 참조에 투명한 모든 x 에 대해 참조가 투명하다면<br>함수 f 는 순수하다(pure)라고 합니다.</p><p>따라서 <code>코드의 블록을 이해하기 위해 일련의 상태 갱신을 따라갈 필요가 없고 국소 추론(local reasoning)만으로도 코드를 이해</code>할 수 있습니다.</p><p><code>모듈적인 프로그램은 독립적으로 재사용할 수 있는 구성요소(component)로 구성</code>됩니다.</p><p>따라서 순수 함수는 입력과 결과가 분리되어 있으며,<br>어떻게 사용되는지에 대해서는 전혀 신경쓰지 않아도 되므로 재사용성이 높아집니다.</p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;컴포넌트와 props&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;컴포넌트를 통해 UI 를 독립적이고 재사용 가능한 부분으로 분리하고,&lt;br&gt;
각 부분을 독립적으로 생각할 수 있습니다.&lt;br&gt;&lt;/p&gt;
&lt;p&gt;개념상 컴포넌트는 자바스크립트 함수와 비슷합니다.&lt;br&gt;
“
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="Component" scheme="https://leekeunhwan.github.io/tags/Component/"/>
    
      <category term="Props" scheme="https://leekeunhwan.github.io/tags/Props/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Elements_Render (요소 렌더링)</title>
    <link href="https://leekeunhwan.github.io/2018/08/01/Elements-Render/"/>
    <id>https://leekeunhwan.github.io/2018/08/01/Elements-Render/</id>
    <published>2018-07-31T15:58:10.000Z</published>
    <updated>2018-08-01T04:43:01.708Z</updated>
    
    <content type="html"><![CDATA[<h2>요소 렌더링</h2><hr><p>요소는 <code>React 앱에서 가장 작은 단위의 재료</code>입니다.<br>요소는 화면에 표시하고자 하는 내용을 서술합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>브라우저 DOM 요소와 달리,<br>React 요소는 순수한 객체이며 생성 비용이 저렴합니다.<br><br>React DOM 라이브러리는 DOM 갱신 작업을 관장하며,<br>React 요소와 DOM 이 일치하도록 만듭니다.<br></p><br><h2>DOM 에서 요소 렌더링하기</h2><hr><p>HTML 파일 어딘가에 <code>&lt;div&gt;</code> 가 있다고 가정해봅시다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React DOM 에 의해 관리되는 모든 것이 이 요소 안에 들어가므로,<br>이걸 <code>“루트” DOM 노드</code>라고 부릅니다.</p><p>React 로 구축한 어플리케이션은 보통 하나의 루트 DOM 노드를 가집니다.<br><br>React 를 기존 앱에 통합하는 경우,<br>원하는 만큼의 여러 루트 DOM 노드를 만들 수도 있습니다.<br><br>React 요소를 루트 DOM 노드에 렌더링하고 싶다면,<br><code>ReactDOM.render()</code> 에 둘 다 넘겨주면 됩니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><br><h2>렌더링된 요소 업데이트</h2><hr><p>React 요소는 변경 불가능 합니다. 한번 요소를 만들었다면,<br>그 자식이나 어트리뷰트를 변경할 수 없습니다.<br>요소는 영화의 단일 프레임에 비유할 수 있습니다.</p><p>즉, 요소는 특정 시점의 UI 를 표현할 뿐입니다.<br><br></p><p>이제까지 배운 것만 가지고 UI 를 갱신할 수 있는 유일한 방법은<br>새로운 요소를 만들어서 이 요소를 <code>ReactDOM.render()</code> 로 전달하는 것입니다.<br></p><p>깜빡이는 시계를 구현한 예제를 살펴봅시다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>이 예제는 <code>setInterval()</code> 콜백을 이용해 매 초마다<br><code>ReactDOM.render()</code> 를 호출하고 있습니다.<br><br>하지만 대부분의 React 어플리케이션은<br><code>ReactDOM.render()</code> 를 <b style="color:salmon;">한 번만</b> 호출합니다<br></p><br><h2>React 는 꼭 필요한 부분만 갱신합니다</h2><hr><p>React DOM 은 요소 및 그 자식을 이전 버전과 비교하고,<br>DOM 을 원하는 상태로 만드는 데 필요한 DOM 업데이트만 적용합니다.<br><strong style="color:salmon;">(Virtual DOM)</strong></p><p>마지막 예제 를 개발자 도구로 관찰해보면 알 수 있습니다.</p><img src="https://github.com/leekeunhwan/Moong2s-TIL/raw/master/image/react_clock.gif" width="400"><p>매 깜빡임마다 전체 UI 트리를 서술하는 요소를 만들었지만,<br>내용이 변경된 텍스트 노드만이 React DOM 에 의해서 업데이트 됩니다.</p><p>우리의 경험상,<br><code>‘시간 경과에 따라 UI 를 어떻게 변경할지’</code>를 생각하는 것이 아니라<br><code>‘특정 순간에 UI 가 어떻게 보여져야 할지’</code>에 대해 생각하면,<br>수많은 종류의 버그를 없앨 수 있습니다.<br></p><p>[Virtual DOM 은 가상의 DOM 으로 실제 DOM 과 비교 알고리즘을 통해<br>변경부분을 파악하고 변경 부분만 렌더링 해줍니다.]<br><br><img src="https://github.com/leekeunhwan/Moong2s-TIL/raw/master/image/virtual_DOM.png" width="500"></p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;요소 렌더링&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;요소는 &lt;code&gt;React 앱에서 가장 작은 단위의 재료&lt;/code&gt;입니다.&lt;br&gt;
요소는 화면에 표시하고자 하는 내용을 서술합니다.&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="Elements_Render" scheme="https://leekeunhwan.github.io/tags/Elements-Render/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>JSX란?</title>
    <link href="https://leekeunhwan.github.io/2018/07/30/JSX/"/>
    <id>https://leekeunhwan.github.io/2018/07/30/JSX/</id>
    <published>2018-07-30T12:49:53.000Z</published>
    <updated>2018-08-01T04:41:51.897Z</updated>
    
    <content type="html"><![CDATA[<h2>JSX 란?</h2><hr><p>JSX 는 자바스크립트의 확장문법으로 JSX 를 리액트와 함께 사용하면<br>UI 가 실제로 어떻게 보일지 서술할 수 있습니다.<br>JSX 는 템플릿 언어처럼 보일 수 있지만 템플릿 언어는 아닙니다.<br>JSX 는 React 요소를 만듭니다.</p><br><h2>왜 JSX 인가?</h2><hr><p>React 는 렌더링 로직이 다른 UI 로직과 본질적으로<br>결합되어 있다는 사실을 인정합니다.</p><p>즉, 이벤트의 처리 과정, 시간에 따른 상태 변화, 표시할 데이터가<br>어디로부터 오는지가 렌더링 로직과 결합되어 있다는 것입니다.</p><p>React 는 별도의 파일에 마크업과 로직을 넣어 기술 을 인위적으로 분리하는 대신,<br>둘 다 포함하는 “컴포넌트”라고 부르는 단위를 이용해 관심사를 분리 합니다.</p><p>React 를 사용하기 위해 반드시 JSX 를 사용해야 하는 것은 아닙니다만,<br>많은 사람들이 자바스크립트 코드 안에서 UI 작업을 할 때<br>시각적으로 더 편하다고 느끼고 있습니다.<br>또한 JSX 를 사용하면 React 가 유용한 에러 및 경고 메시지를 표시해줄 수 있습니다.</p><br><h2>JSX 에 표현식 포함하기</h2><hr><p>JSX 안에 자바스크립트 표현식 을 중괄호로 묶어서 포함시킬 수 있습니다.<br>(JSX 에서 중괄호를 쓰면 중괄호 안에서 자유롭게 자바스크립트를 다룰 수 있습니다.)<br><br>예를 들어, 2 + 2, user.firstName, formatName(user) 를<br>유효한 표현식으로 표현하면 아래와 같이 표현합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">" "</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">"Harper"</span>,</span><br><span class="line">  lastName: <span class="string">"Perez"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure><p>가독성을 좋게 하기 위해 JSX 를 여러줄로 나눴습니다.<br><br>필수는 아니지만, 이 작업을 수행할 때는 자동 세미콜론 삽입의 함정을 피하기 위해<br>괄호로 묶는 것이 좋습니다.</p><br><h2>JSX 또한 표현식이다</h2><hr><p>컴파일이 끝나면, JSX 표현식이 일반적인 자바스크립트 함수 호출이 되고,<br>결과적으로 자바스크립트 객체로 평가됩니다.<br>이 말은 if 문이나 for 문 내에서 JSX 를 사용할 수 있으며,<br>변수에 할당하거나 매개변수로 전달하거나 함수에서 반환할 수 있음을 의미합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2>JSX 어트리뷰트 정의</h2><hr><p>어트리뷰트에서 따옴표를 사용해서 문자열 리터럴을 정의할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>어트리뷰트에 중괄호를 사용하면, 자바스크립트 표현식을 포함시킬 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>어트리뷰트에 자바스크립트 표현식을 포함시킬 때 중괄호를 따옴표로 묶지 마세요.<br>따옴표 (문자열 값인 경우) 또는 중괄호 (표현식인 경우) 중 하나를 사용해야 하며,<br>하나의 어트리뷰트에 둘 다 사용할 수 있는 것이 아닙니다.</p><p><strong stlye="color:salmon">경고</strong></p><p>JSX 는 HTML 보다는 자바스크립트에 가깝기 때문에,<br>React DOM 은 HTML 어트리뷰트 이름 대신<br>camelCase 어트리뷰트 이름 컨벤션을 사용합니다.</p><p>예를 들어, JSX 에서 class 는 <code>className</code> 이 되며, tabindex 는 <code>tabIndex</code> 가 됩니다.</p><br><h3>예를 들면 이렇게</h3><table><thead><tr><th style="text-align:center">HTML Attribute</th><th style="text-align:center">HTML Example</th><th style="text-align:center">JSX Property</th><th style="text-align:center">JSX Example</th></tr></thead><tbody><tr><td style="text-align:center">class</td><td style="text-align:center"><code>&lt;div class='fancy'&gt;...&lt;/div&gt;</code></td><td style="text-align:center">className*</td><td style="text-align:center"><code>&lt;div className='fancy'&gt;...&lt;/div&gt;</code></td></tr><tr><td style="text-align:center">onclick</td><td style="text-align:center"><code>&lt;button onclick=&quot;foo()&quot;&gt;...</code></td><td style="text-align:center">onClick*</td><td style="text-align:center"><code>&lt;button onClick={foo}&gt;...</code><br><code>&lt;button onClick={() =&gt; foo(param)}&gt;...</code></td></tr><tr><td style="text-align:center">tabindex</td><td style="text-align:center"><code>&lt;input tabindex=2 /&gt;</code></td><td style="text-align:center">tabIndex</td><td style="text-align:center"><code>&lt;input tabIndex={2} /&gt;</code></td></tr></tbody></table><br><br><h3>HTML vs Web API vs React JSX</h3><table><thead><tr><th style="text-align:center">Difference</th><th style="text-align:center">HTML</th><th style="text-align:center">Web API</th><th style="text-align:center">React JSX</th></tr></thead><tbody><tr><td style="text-align:center">Names of attributes / properties</td><td style="text-align:center">lower case</td><td style="text-align:center">(mostly) camelCase</td><td style="text-align:center"><strong>camelCase</strong></td></tr><tr><td style="text-align:center">Values of attributes / properties</td><td style="text-align:center">string</td><td style="text-align:center">expression</td><td style="text-align:center">expression within <code>{ }</code></td></tr><tr><td style="text-align:center">Names of event handlers (on…)</td><td style="text-align:center">lower case</td><td style="text-align:center">lower case (!)</td><td style="text-align:center"><strong>camelCase</strong></td></tr><tr><td style="text-align:center">Values of event handlers (on…)</td><td style="text-align:center">JavaScript string</td><td style="text-align:center">function expr.</td><td style="text-align:center">function expr. within <code>{ }</code></td></tr><tr><td style="text-align:center">Event Handlers: prevent default behaviour</td><td style="text-align:center">n/a</td><td style="text-align:center">can return <code>false</code></td><td style="text-align:center">must call <code>event.preventDefault();</code></td></tr><tr><td style="text-align:center">HTML Tags</td><td style="text-align:center">lower case</td><td style="text-align:center">n/a*</td><td style="text-align:center">lower case</td></tr><tr><td style="text-align:center">Custom Tags (Components)</td><td style="text-align:center">n/a</td><td style="text-align:center">n/a</td><td style="text-align:center">start with <strong>capital letter</strong></td></tr></tbody></table><br><br><h2>JSX 자식 정의</h2><hr><p>만약 태그가 비어있다면, XML 처럼 /&gt; 를 이용해 닫아주어야 합니다. (빈태그 문법)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>JSX 태그는 자식을 가질 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><h2>JSX 인젝션 공격 예방</h2><hr><p>사용자가 입력한 내용을 JSX 내에 포함시켜도 안전합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>기본적으로, React DOM 은 렌더링 되기 전에<br>JSX 내에 포함된 모든 값을 이스케이프 합니다.</p><p>따라서 어플리케이션에 명시적으로 작성되지 않은 내용은 절대 삽입할 수 없습니다.<br>모든 것은 렌더링 되기 전에 문자열로 변환됩니다.<br>이렇게 하면 XSS (cross-site-scripting) 공격을 막을 수 있습니다.</p><br><h2>JSX 객체 표현</h2><hr><p>Babel 은 JSX 를 React.createElement() 호출로 컴파일합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsx</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"greeting"</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">"h1"</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">"greeting"</span> &#125;,</span><br><span class="line">  <span class="string">"Hello, world!"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>React.createElement() 는 버그 없는 코드를 작성하는 데<br>도움을 주는 몇 가지 체크를 하긴 하지만,<br>기본적으로는 아래와 같은 객체를 생성합니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: this structure is simplified</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">"h1"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">"greeting"</span>,</span><br><span class="line">    children: <span class="string">"Hello, world"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이 객체를 “React 요소”라고 부릅니다.<br>화면에서 보고자 하는 내용에 대한 설명 내지 서술로 생각할 수 있습니다.<br>React 는 이 객체를 읽어들이고 이를 사용하여<br>DOM 을 만들어낸 뒤 최신 상태로 유지합니다.<br><br></p><p>팁 : ES6 및 JSX 코드가 모두 올바르게 표시되도록<br>선택한 편집기에 “Babel” 언어 설정 을 사용하는 것이 좋습니다.<br></p><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;JSX 란?&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;JSX 는 자바스크립트의 확장문법으로 JSX 를 리액트와 함께 사용하면&lt;br&gt;
UI 가 실제로 어떻게 보일지 서술할 수 있습니다.&lt;br&gt;
JSX 는 템플릿 언어처럼 보일 수 있지만 템플릿 언어는 아닙니다.&lt;b
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="JSX" scheme="https://leekeunhwan.github.io/tags/JSX/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>React 16의 특징</title>
    <link href="https://leekeunhwan.github.io/2018/06/12/React16/"/>
    <id>https://leekeunhwan.github.io/2018/06/12/React16/</id>
    <published>2018-06-12T09:18:30.000Z</published>
    <updated>2018-08-01T04:41:57.972Z</updated>
    
    <content type="html"><![CDATA[<h2>How To Change Multiple JSX Elements Return</h2><p>기존에는 JSX Elements 를 Render 함에 있어서<br>한개의 JSX Elements 만 가능해서 div, span 태그로 감싸서<br>렌더링을 하곤 하였습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이렇게 말이죠</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;h1&gt;hello world&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 React 16 에서는 React.Fragment 를 지원합니다.<br>span 이나 div 로 감싸게 되는 경우에는 CSS 를 할 때<br>꼬이거나 뭔가 문제가 생길 가능성이 있는데<br>React.Fragment 태그를 사용하게 되면 기존 span 과 div 로<br>감쌀때처럼 잘 출력이 되면서도 문제가 생길 가능성이 많이 줄어들어<br>좋은 기능이라고 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;header /&gt;</span><br><span class="line">        &lt;div /&gt;</span><br><span class="line">        &lt;footer /&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br><br><h2>Strings are returned.</h2><p>기존의 React 에서는 오직 return 할 수 있는 것이<br><code>Component</code> 아니면 <code>Null</code> 이였습니다.<br>하지만 React 16 부터는 아래처럼 string 을 return 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringReturn</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;StringReturn /&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ hello</span></span><br></pre></td></tr></table></figure><br><br><h2>portals</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>portals 는 React root 밖에서 렌더를 할 때 사용할 수 있는 기능입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>What is Portals?<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"here"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPortal &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Portals</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> createPortal(<span class="xml"><span class="tag">&lt;<span class="name">Message</span> /&gt;</span>, documents.getElementById("here"));</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const Message = () =&gt; "This is Portals";</span></span><br></pre></td></tr></table></figure><p>portals 는 html 을 변경하지 못할 때 유용하게 사용될 수 있습니다.</p><br><br><h2>Error Boundaries</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorMaker</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    friends: [<span class="string">"jisu"</span>, <span class="string">"flynn"</span>, <span class="string">"daal"</span>, <span class="string">"kneeprayer"</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        friends: <span class="literal">undefined</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; friends &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> friends.map(<span class="function"><span class="params">friend</span> =&gt;</span> <span class="string">` <span class="subst">$&#123;friend&#125;</span> `</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ErrorFallback = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">" Sorry something went wrong"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    hasError: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidCatch = <span class="function">(<span class="params">error, info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      hasError: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &#123;hasError ? <span class="xml"><span class="tag">&lt;<span class="name">ErrorFallback</span> /&gt;</span> : <span class="tag">&lt;<span class="name">ErrorMaker</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">    );</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>기존에는 에러가 발생하면 리액트 앱이 죽어버렸는데<br>React16 에서는 componentDidCatch 를 통해<br>컴포넌트가 에러를 캐치하면 기존에 정상적으로 작동하는 것들은 살려두고<br>에러에만 대응하는 모습을 볼 수 있습니다.</p><br><br><h2>Error Boundaries with Higher Order Components</h2><p>컴포넌트에서 에러를 잡는 것은 굉장히 매력적인 일이지만<br>JSX 엘리먼트가 많다면 에러를 잡기 위해 그 많은 코드에다가<br>일일히 삼항연산자로 에러를 잡는 코드를 만드는 것은 굉장히 비효율적입니다.<br>그래서 있는 것이 <code>HOC(고차 컴포넌트)</code> 입니다.</p><p>개발단에서만 에러가 발생시 보이므로 사용자 경험을 좋도록 할 수 있습니다.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createPortal &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoundaryHOC = <span class="function"><span class="params">ProtectedComponent</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Boundary</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">      hasError: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    componentDidCatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        hasError: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; hasError &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">      <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ErrorFallback</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">      &#125; else &#123;</span></span><br><span class="line"><span class="xml">        return <span class="tag">&lt;<span class="name">ProtectedComponent</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class ErrorMaker extends Component &#123;</span></span><br><span class="line"><span class="xml">  state = &#123;</span></span><br><span class="line"><span class="xml">    friends: ["jisu", "flynn", "daal", "kneeprayer"]</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">  componentDidMount = () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="xml">      this.setState(&#123;</span></span><br><span class="line"><span class="xml">        friends: undefined</span></span><br><span class="line"><span class="xml">      &#125;);</span></span><br><span class="line"><span class="xml">    &#125;, 2000);</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    const &#123; friends &#125; = this.state;</span></span><br><span class="line"><span class="xml">    return friends.map(friend =&gt; ` $&#123;friend&#125; `);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const PErrorMaker = BoundaryHOC(ErrorMaker);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class Portals extends Component &#123;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return createPortal(<span class="tag">&lt;<span class="name">Message</span> /&gt;</span>, document.getElementById("touchme"));</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const PPortals = BoundaryHOC(Portals);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const Message = () =&gt; "Just touched it!";</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class ReturnTypes extends Component &#123;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return "hello";</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const ErrorFallback = () =&gt; "Sorry something went wrong";</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class App extends Component &#123;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;ReturnTypes /&gt;</span><br><span class="line">        &lt;PPortals /&gt;</span><br><span class="line">        &lt;PErrorMaker /&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">    );</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default BoundaryHOC(App);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;How To Change Multiple JSX Elements Return&lt;/h2&gt;
&lt;p&gt;기존에는 JSX Elements 를 Render 함에 있어서&lt;br&gt;
한개의 JSX Elements 만 가능해서 div, span 태그로 감싸서&lt;br&gt;
렌
      
    
    </summary>
    
      <category term="React" scheme="https://leekeunhwan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://leekeunhwan.github.io/tags/React/"/>
    
      <category term="React16" scheme="https://leekeunhwan.github.io/tags/React16/"/>
    
      <category term="TIL" scheme="https://leekeunhwan.github.io/tags/TIL/"/>
    
  </entry>
  
</feed>
